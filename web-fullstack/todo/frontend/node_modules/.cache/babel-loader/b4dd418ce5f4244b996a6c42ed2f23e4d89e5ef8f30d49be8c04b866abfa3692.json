{"ast":null,"code":"'use strict';\n\nvar STRING_FORMAT_REG = require('../var/STRING_FORMAT_REG'),\n  CommonChars = require('../var/CommonChars'),\n  memoizeFunction = require('./memoizeFunction');\nvar OPEN_BRACE = CommonChars.OPEN_BRACE,\n  CLOSE_BRACE = CommonChars.CLOSE_BRACE;\nfunction createFormatMatcher(bracketMatcher, percentMatcher, precheck) {\n  var reg = STRING_FORMAT_REG;\n  var compileMemoized = memoizeFunction(compile);\n  function getToken(format, match) {\n    var get, token, literal, fn;\n    var bKey = match[2];\n    var pLit = match[3];\n    var pKey = match[5];\n    if (match[4] && percentMatcher) {\n      token = pKey;\n      get = percentMatcher;\n    } else if (bKey) {\n      token = bKey;\n      get = bracketMatcher;\n    } else if (pLit && percentMatcher) {\n      literal = pLit;\n    } else {\n      literal = match[1] || match[0];\n    }\n    if (get) {\n      assertPassesPrecheck(precheck, bKey, pKey);\n      fn = function (obj, opt) {\n        return get(obj, token, opt);\n      };\n    }\n    format.push(fn || getLiteral(literal));\n  }\n  function getSubstring(format, str, start, end) {\n    if (end > start) {\n      var sub = str.slice(start, end);\n      assertNoUnmatched(sub, OPEN_BRACE);\n      assertNoUnmatched(sub, CLOSE_BRACE);\n      format.push(function () {\n        return sub;\n      });\n    }\n  }\n  function getLiteral(str) {\n    return function () {\n      return str;\n    };\n  }\n  function assertPassesPrecheck(precheck, bt, pt) {\n    if (precheck && !precheck(bt, pt)) {\n      throw new TypeError('Invalid token ' + (bt || pt) + ' in format string');\n    }\n  }\n  function assertNoUnmatched(str, chr) {\n    if (str.indexOf(chr) !== -1) {\n      throw new TypeError('Unmatched ' + chr + ' in format string');\n    }\n  }\n  function compile(str) {\n    var format = [],\n      lastIndex = 0,\n      match;\n    reg.lastIndex = 0;\n    while (match = reg.exec(str)) {\n      getSubstring(format, str, lastIndex, match.index);\n      getToken(format, match);\n      lastIndex = reg.lastIndex;\n    }\n    getSubstring(format, str, lastIndex, str.length);\n    return format;\n  }\n  return function (str, obj, opt) {\n    var format = compileMemoized(str),\n      result = '';\n    for (var i = 0; i < format.length; i++) {\n      result += format[i](obj, opt);\n    }\n    return result;\n  };\n}\nmodule.exports = createFormatMatcher;","map":{"version":3,"names":["STRING_FORMAT_REG","require","CommonChars","memoizeFunction","OPEN_BRACE","CLOSE_BRACE","createFormatMatcher","bracketMatcher","percentMatcher","precheck","reg","compileMemoized","compile","getToken","format","match","get","token","literal","fn","bKey","pLit","pKey","assertPassesPrecheck","obj","opt","push","getLiteral","getSubstring","str","start","end","sub","slice","assertNoUnmatched","bt","pt","TypeError","chr","indexOf","lastIndex","exec","index","length","result","i","module","exports"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/todo/node_modules/sugar-date/common/internal/createFormatMatcher.js"],"sourcesContent":["'use strict';\n\nvar STRING_FORMAT_REG = require('../var/STRING_FORMAT_REG'),\n    CommonChars = require('../var/CommonChars'),\n    memoizeFunction = require('./memoizeFunction');\n\nvar OPEN_BRACE = CommonChars.OPEN_BRACE,\n    CLOSE_BRACE = CommonChars.CLOSE_BRACE;\n\nfunction createFormatMatcher(bracketMatcher, percentMatcher, precheck) {\n\n  var reg = STRING_FORMAT_REG;\n  var compileMemoized = memoizeFunction(compile);\n\n  function getToken(format, match) {\n    var get, token, literal, fn;\n    var bKey = match[2];\n    var pLit = match[3];\n    var pKey = match[5];\n    if (match[4] && percentMatcher) {\n      token = pKey;\n      get = percentMatcher;\n    } else if (bKey) {\n      token = bKey;\n      get = bracketMatcher;\n    } else if (pLit && percentMatcher) {\n      literal = pLit;\n    } else {\n      literal = match[1] || match[0];\n    }\n    if (get) {\n      assertPassesPrecheck(precheck, bKey, pKey);\n      fn = function(obj, opt) {\n        return get(obj, token, opt);\n      };\n    }\n    format.push(fn || getLiteral(literal));\n  }\n\n  function getSubstring(format, str, start, end) {\n    if (end > start) {\n      var sub = str.slice(start, end);\n      assertNoUnmatched(sub, OPEN_BRACE);\n      assertNoUnmatched(sub, CLOSE_BRACE);\n      format.push(function() {\n        return sub;\n      });\n    }\n  }\n\n  function getLiteral(str) {\n    return function() {\n      return str;\n    };\n  }\n\n  function assertPassesPrecheck(precheck, bt, pt) {\n    if (precheck && !precheck(bt, pt)) {\n      throw new TypeError('Invalid token '+ (bt || pt) +' in format string');\n    }\n  }\n\n  function assertNoUnmatched(str, chr) {\n    if (str.indexOf(chr) !== -1) {\n      throw new TypeError('Unmatched '+ chr +' in format string');\n    }\n  }\n\n  function compile(str) {\n    var format = [], lastIndex = 0, match;\n    reg.lastIndex = 0;\n    while(match = reg.exec(str)) {\n      getSubstring(format, str, lastIndex, match.index);\n      getToken(format, match);\n      lastIndex = reg.lastIndex;\n    }\n    getSubstring(format, str, lastIndex, str.length);\n    return format;\n  }\n\n  return function(str, obj, opt) {\n    var format = compileMemoized(str), result = '';\n    for (var i = 0; i < format.length; i++) {\n      result += format[i](obj, opt);\n    }\n    return result;\n  };\n}\n\nmodule.exports = createFormatMatcher;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}