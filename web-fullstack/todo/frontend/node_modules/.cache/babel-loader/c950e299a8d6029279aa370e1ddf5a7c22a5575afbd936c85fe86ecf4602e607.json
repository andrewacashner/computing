{"ast":null,"code":"'use strict';\n\nvar DateUnits = require('../var/DateUnits'),\n  DateUnitIndexes = require('../var/DateUnitIndexes'),\n  trunc = require('../../common/var/trunc'),\n  setDate = require('./setDate'),\n  getDate = require('./getDate'),\n  getMonth = require('./getMonth'),\n  getNewDate = require('./getNewDate'),\n  setWeekday = require('./setWeekday'),\n  mathAliases = require('../../common/var/mathAliases'),\n  callDateGet = require('../../common/internal/callDateGet'),\n  classChecks = require('../../common/var/classChecks'),\n  resetLowerUnits = require('./resetLowerUnits'),\n  getLowerUnitIndex = require('./getLowerUnitIndex'),\n  getHigherUnitIndex = require('./getHigherUnitIndex'),\n  callDateSetWithWeek = require('./callDateSetWithWeek'),\n  iterateOverDateParams = require('./iterateOverDateParams');\nvar DAY_INDEX = DateUnitIndexes.DAY_INDEX,\n  WEEK_INDEX = DateUnitIndexes.WEEK_INDEX,\n  MONTH_INDEX = DateUnitIndexes.MONTH_INDEX,\n  YEAR_INDEX = DateUnitIndexes.YEAR_INDEX,\n  round = mathAliases.round,\n  isNumber = classChecks.isNumber;\nfunction updateDate(d, params, reset, advance, prefer, weekdayDir, contextDate) {\n  var upperUnitIndex;\n  function setUpperUnit(unitName, unitIndex) {\n    if (prefer && !upperUnitIndex) {\n      if (unitName === 'weekday') {\n        upperUnitIndex = WEEK_INDEX;\n      } else {\n        upperUnitIndex = getHigherUnitIndex(unitIndex);\n      }\n    }\n  }\n  function setSpecificity(unitIndex) {\n    // Other functions may preemptively set the specificity before arriving\n    // here so concede to them if they have already set more specific units.\n    if (unitIndex > params.specificity) {\n      return;\n    }\n    params.specificity = unitIndex;\n  }\n  function canDisambiguate() {\n    if (!upperUnitIndex || upperUnitIndex > YEAR_INDEX) {\n      return;\n    }\n    switch (prefer) {\n      case -1:\n        return d >= (contextDate || getNewDate());\n      case 1:\n        return d <= (contextDate || getNewDate());\n    }\n  }\n  function disambiguateHigherUnit() {\n    var unit = DateUnits[upperUnitIndex];\n    advance = prefer;\n    setUnit(unit.name, 1, unit, upperUnitIndex);\n  }\n  function handleFraction(unit, unitIndex, fraction) {\n    if (unitIndex) {\n      var lowerUnit = DateUnits[getLowerUnitIndex(unitIndex)];\n      var val = round(unit.multiplier / lowerUnit.multiplier * fraction);\n      params[lowerUnit.name] = val;\n    }\n  }\n  function monthHasShifted(d, targetMonth) {\n    if (targetMonth < 0) {\n      targetMonth = targetMonth % 12 + 12;\n    }\n    return targetMonth % 12 !== getMonth(d);\n  }\n  function setUnit(unitName, value, unit, unitIndex) {\n    var method = unit.method,\n      checkMonth,\n      fraction;\n    setUpperUnit(unitName, unitIndex);\n    setSpecificity(unitIndex);\n    fraction = value % 1;\n    if (fraction) {\n      handleFraction(unit, unitIndex, fraction);\n      value = trunc(value);\n    }\n    if (unitName === 'weekday') {\n      if (!advance) {\n        // Weekdays are always considered absolute units so simply set them\n        // here even if it is an \"advance\" operation. This is to help avoid\n        // ambiguous meanings in \"advance\" as well as to neatly allow formats\n        // like \"Wednesday of next week\" without more complex logic.\n        setWeekday(d, value, weekdayDir);\n      }\n      return;\n    }\n    checkMonth = unitIndex === MONTH_INDEX && getDate(d) > 28;\n\n    // If we are advancing or rewinding, then we need we need to set the\n    // absolute time if the unit is \"hours\" or less. This is due to the fact\n    // that setting by method is ambiguous during DST shifts. For example,\n    // 1:00am on November 1st 2015 occurs twice in North American timezones\n    // with DST, the second time being after the clocks are rolled back at\n    // 2:00am. When springing forward this is automatically handled as there\n    // is no 2:00am so the date automatically jumps to 3:00am. However, when\n    // rolling back, setHours(2) will always choose the first \"2am\" even if\n    // the date is currently set to the second, causing unintended jumps.\n    // This ambiguity is unavoidable when setting dates as the notation is\n    // ambiguous. However when advancing, we clearly want the resulting date\n    // to be an acutal hour ahead, which can only be accomplished by setting\n    // the absolute time. Conversely, any unit higher than \"hours\" MUST use\n    // the internal set methods, as they are ambiguous as absolute units of\n    // time. Years may be 365 or 366 days depending on leap years, months are\n    // all over the place, and even days may be 23-25 hours depending on DST\n    // shifts. Finally, note that the kind of jumping described above will\n    // occur when calling ANY \"set\" method on the date and will occur even if\n    // the value being set is identical to the one currently set (i.e.\n    // setHours(2) on a date at 2am may not be a noop). This is precarious,\n    // so avoiding this situation in callDateSet by checking up front that\n    // the value is not the same before setting.\n    if (advance && !unit.ambiguous) {\n      d.setTime(d.getTime() + value * advance * unit.multiplier);\n      return;\n    } else if (advance) {\n      if (unitIndex === WEEK_INDEX) {\n        value *= 7;\n        method = DateUnits[DAY_INDEX].method;\n      }\n      value = value * advance + callDateGet(d, method);\n    }\n    callDateSetWithWeek(d, method, value, advance);\n    if (checkMonth && monthHasShifted(d, value)) {\n      // As we are setting the units in reverse order, there is a chance that\n      // our date may accidentally traverse into a new month, such as setting\n      // { month: 1, date 15 } on January 31st. Check for this here and reset\n      // the date to the last day of the previous month if this has happened.\n      setDate(d, 0);\n    }\n  }\n  if (isNumber(params) && advance) {\n    // If param is a number and advancing, the number is in milliseconds.\n    params = {\n      millisecond: params\n    };\n  } else if (isNumber(params)) {\n    // Otherwise just set the timestamp and return.\n    d.setTime(params);\n    return d;\n  }\n  iterateOverDateParams(params, setUnit);\n  if (reset && params.specificity) {\n    resetLowerUnits(d, params.specificity);\n  }\n\n  // If past or future is preferred, then the process of \"disambiguation\" will\n  // ensure that an ambiguous time/date (\"4pm\", \"thursday\", \"June\", etc.) will\n  // be in the past or future. Weeks are only considered ambiguous if there is\n  // a weekday, i.e. \"thursday\" is an ambiguous week, but \"the 4th\" is an\n  // ambiguous month.\n  if (canDisambiguate()) {\n    disambiguateHigherUnit();\n  }\n  return d;\n}\nmodule.exports = updateDate;","map":{"version":3,"names":["DateUnits","require","DateUnitIndexes","trunc","setDate","getDate","getMonth","getNewDate","setWeekday","mathAliases","callDateGet","classChecks","resetLowerUnits","getLowerUnitIndex","getHigherUnitIndex","callDateSetWithWeek","iterateOverDateParams","DAY_INDEX","WEEK_INDEX","MONTH_INDEX","YEAR_INDEX","round","isNumber","updateDate","d","params","reset","advance","prefer","weekdayDir","contextDate","upperUnitIndex","setUpperUnit","unitName","unitIndex","setSpecificity","specificity","canDisambiguate","disambiguateHigherUnit","unit","setUnit","name","handleFraction","fraction","lowerUnit","val","multiplier","monthHasShifted","targetMonth","value","method","checkMonth","ambiguous","setTime","getTime","millisecond","module","exports"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/todo/node_modules/sugar-date/date/internal/updateDate.js"],"sourcesContent":["'use strict';\n\nvar DateUnits = require('../var/DateUnits'),\n    DateUnitIndexes = require('../var/DateUnitIndexes'),\n    trunc = require('../../common/var/trunc'),\n    setDate = require('./setDate'),\n    getDate = require('./getDate'),\n    getMonth = require('./getMonth'),\n    getNewDate = require('./getNewDate'),\n    setWeekday = require('./setWeekday'),\n    mathAliases = require('../../common/var/mathAliases'),\n    callDateGet = require('../../common/internal/callDateGet'),\n    classChecks = require('../../common/var/classChecks'),\n    resetLowerUnits = require('./resetLowerUnits'),\n    getLowerUnitIndex = require('./getLowerUnitIndex'),\n    getHigherUnitIndex = require('./getHigherUnitIndex'),\n    callDateSetWithWeek = require('./callDateSetWithWeek'),\n    iterateOverDateParams = require('./iterateOverDateParams');\n\nvar DAY_INDEX = DateUnitIndexes.DAY_INDEX,\n    WEEK_INDEX = DateUnitIndexes.WEEK_INDEX,\n    MONTH_INDEX = DateUnitIndexes.MONTH_INDEX,\n    YEAR_INDEX = DateUnitIndexes.YEAR_INDEX,\n    round = mathAliases.round,\n    isNumber = classChecks.isNumber;\n\nfunction updateDate(d, params, reset, advance, prefer, weekdayDir, contextDate) {\n  var upperUnitIndex;\n\n  function setUpperUnit(unitName, unitIndex) {\n    if (prefer && !upperUnitIndex) {\n      if (unitName === 'weekday') {\n        upperUnitIndex = WEEK_INDEX;\n      } else {\n        upperUnitIndex = getHigherUnitIndex(unitIndex);\n      }\n    }\n  }\n\n  function setSpecificity(unitIndex) {\n    // Other functions may preemptively set the specificity before arriving\n    // here so concede to them if they have already set more specific units.\n    if (unitIndex > params.specificity) {\n      return;\n    }\n    params.specificity = unitIndex;\n  }\n\n  function canDisambiguate() {\n    if (!upperUnitIndex || upperUnitIndex > YEAR_INDEX) {\n      return;\n    }\n\n    switch(prefer) {\n      case -1: return d >= (contextDate || getNewDate());\n      case  1: return d <= (contextDate || getNewDate());\n    }\n  }\n\n  function disambiguateHigherUnit() {\n    var unit = DateUnits[upperUnitIndex];\n    advance = prefer;\n    setUnit(unit.name, 1, unit, upperUnitIndex);\n  }\n\n  function handleFraction(unit, unitIndex, fraction) {\n    if (unitIndex) {\n      var lowerUnit = DateUnits[getLowerUnitIndex(unitIndex)];\n      var val = round(unit.multiplier / lowerUnit.multiplier * fraction);\n      params[lowerUnit.name] = val;\n    }\n  }\n\n  function monthHasShifted(d, targetMonth) {\n    if (targetMonth < 0) {\n      targetMonth = targetMonth % 12 + 12;\n    }\n    return targetMonth % 12 !== getMonth(d);\n  }\n\n  function setUnit(unitName, value, unit, unitIndex) {\n    var method = unit.method, checkMonth, fraction;\n\n    setUpperUnit(unitName, unitIndex);\n    setSpecificity(unitIndex);\n\n    fraction = value % 1;\n    if (fraction) {\n      handleFraction(unit, unitIndex, fraction);\n      value = trunc(value);\n    }\n\n    if (unitName === 'weekday') {\n      if (!advance) {\n        // Weekdays are always considered absolute units so simply set them\n        // here even if it is an \"advance\" operation. This is to help avoid\n        // ambiguous meanings in \"advance\" as well as to neatly allow formats\n        // like \"Wednesday of next week\" without more complex logic.\n        setWeekday(d, value, weekdayDir);\n      }\n      return;\n    }\n    checkMonth = unitIndex === MONTH_INDEX && getDate(d) > 28;\n\n    // If we are advancing or rewinding, then we need we need to set the\n    // absolute time if the unit is \"hours\" or less. This is due to the fact\n    // that setting by method is ambiguous during DST shifts. For example,\n    // 1:00am on November 1st 2015 occurs twice in North American timezones\n    // with DST, the second time being after the clocks are rolled back at\n    // 2:00am. When springing forward this is automatically handled as there\n    // is no 2:00am so the date automatically jumps to 3:00am. However, when\n    // rolling back, setHours(2) will always choose the first \"2am\" even if\n    // the date is currently set to the second, causing unintended jumps.\n    // This ambiguity is unavoidable when setting dates as the notation is\n    // ambiguous. However when advancing, we clearly want the resulting date\n    // to be an acutal hour ahead, which can only be accomplished by setting\n    // the absolute time. Conversely, any unit higher than \"hours\" MUST use\n    // the internal set methods, as they are ambiguous as absolute units of\n    // time. Years may be 365 or 366 days depending on leap years, months are\n    // all over the place, and even days may be 23-25 hours depending on DST\n    // shifts. Finally, note that the kind of jumping described above will\n    // occur when calling ANY \"set\" method on the date and will occur even if\n    // the value being set is identical to the one currently set (i.e.\n    // setHours(2) on a date at 2am may not be a noop). This is precarious,\n    // so avoiding this situation in callDateSet by checking up front that\n    // the value is not the same before setting.\n    if (advance && !unit.ambiguous) {\n      d.setTime(d.getTime() + (value * advance * unit.multiplier));\n      return;\n    } else if (advance) {\n      if (unitIndex === WEEK_INDEX) {\n        value *= 7;\n        method = DateUnits[DAY_INDEX].method;\n      }\n      value = (value * advance) + callDateGet(d, method);\n    }\n    callDateSetWithWeek(d, method, value, advance);\n    if (checkMonth && monthHasShifted(d, value)) {\n      // As we are setting the units in reverse order, there is a chance that\n      // our date may accidentally traverse into a new month, such as setting\n      // { month: 1, date 15 } on January 31st. Check for this here and reset\n      // the date to the last day of the previous month if this has happened.\n      setDate(d, 0);\n    }\n  }\n\n  if (isNumber(params) && advance) {\n    // If param is a number and advancing, the number is in milliseconds.\n    params = { millisecond: params };\n  } else if (isNumber(params)) {\n    // Otherwise just set the timestamp and return.\n    d.setTime(params);\n    return d;\n  }\n\n  iterateOverDateParams(params, setUnit);\n\n  if (reset && params.specificity) {\n    resetLowerUnits(d, params.specificity);\n  }\n\n  // If past or future is preferred, then the process of \"disambiguation\" will\n  // ensure that an ambiguous time/date (\"4pm\", \"thursday\", \"June\", etc.) will\n  // be in the past or future. Weeks are only considered ambiguous if there is\n  // a weekday, i.e. \"thursday\" is an ambiguous week, but \"the 4th\" is an\n  // ambiguous month.\n  if (canDisambiguate()) {\n    disambiguateHigherUnit();\n  }\n  return d;\n}\n\nmodule.exports = updateDate;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}