{"ast":null,"code":"/*\n *  Sugar v2.0.6\n *\n *  Freely distributable and licensed under the MIT-style license.\n *  Copyright (c) Andrew Plummer\n *  https://sugarjs.com/\n *\n * ---------------------------- */\n(function () {\n  'use strict';\n\n  /***\n   * @module Core\n   * @description Core functionality including the ability to define methods and\n   *              extend onto natives.\n   *\n   ***/\n\n  // The global to export.\n  var Sugar;\n\n  // The name of Sugar in the global namespace.\n  var SUGAR_GLOBAL = 'Sugar';\n\n  // Natives available on initialization. Letting Object go first to ensure its\n  // global is set by the time the rest are checking for chainable Object methods.\n  var NATIVE_NAMES = 'Object Number String Array Date RegExp Function';\n\n  // Static method flag\n  var STATIC = 0x1;\n\n  // Instance method flag\n  var INSTANCE = 0x2;\n\n  // IE8 has a broken defineProperty but no defineProperties so this saves a try/catch.\n  var PROPERTY_DESCRIPTOR_SUPPORT = !!(Object.defineProperty && Object.defineProperties);\n  var globalContext = getGlobal();\n\n  // Whether object instance methods can be mapped to the prototype.\n  var allowObjectPrototype = false;\n\n  // A map from Array to SugarArray.\n  var namespacesByName = {};\n\n  // A map from [object Object] to namespace.\n  var namespacesByClassString = {};\n\n  // Defining properties.\n  // istanbul ignore next\n  var defineProperty = PROPERTY_DESCRIPTOR_SUPPORT ? Object.defineProperty : definePropertyShim;\n\n  // A default chainable class for unknown types.\n  var DefaultChainable = getNewChainableClass('Chainable');\n\n  // Global methods\n\n  function getGlobal() {\n    // Get global context by keyword here to avoid issues with libraries\n    // that can potentially alter this script's context object.\n    return testGlobal(typeof global !== 'undefined' && global) || testGlobal(typeof window !== 'undefined' && window);\n  }\n  function testGlobal(obj) {\n    // Note that Rhino uses a different \"global\" keyword so perform an\n    // extra check here to ensure that it's actually the global object.\n    return obj && obj.Object === Object ? obj : null;\n  }\n  function setupGlobal() {\n    Sugar = globalContext[SUGAR_GLOBAL];\n    // istanbul ignore if\n    if (Sugar) {\n      // Reuse already defined Sugar global object.\n      return;\n    }\n    Sugar = function (arg) {\n      forEachProperty(Sugar, function (sugarNamespace, name) {\n        // Although only the only enumerable properties on the global\n        // object are Sugar namespaces, environments that can't set\n        // non-enumerable properties will step through the utility methods\n        // as well here, so use this check to only allow true namespaces.\n        if (hasOwn(namespacesByName, name)) {\n          sugarNamespace.extend(arg);\n        }\n      });\n      return Sugar;\n    };\n    // istanbul ignore else\n    if (typeof module !== 'undefined' && module.exports) {\n      // Node or webpack environment\n      module.exports = Sugar;\n    } else {\n      // Unwrapped browser environment\n      try {\n        globalContext[SUGAR_GLOBAL] = Sugar;\n      } catch (e) {\n        // Contexts such as QML have a read-only global context.\n      }\n    }\n    forEachProperty(NATIVE_NAMES.split(' '), function (name) {\n      createNamespace(name);\n    });\n    setGlobalProperties();\n  }\n\n  /***\n   * @method createNamespace(name)\n   * @returns SugarNamespace\n   * @namespace Sugar\n   * @short Creates a new Sugar namespace.\n   * @extra This method is for plugin developers who want to define methods to be\n   *        used with natives that Sugar does not handle by default. The new\n   *        namespace will appear on the `Sugar` global with all the methods of\n   *        normal namespaces, including the ability to define new methods. When\n   *        extended, any defined methods will be mapped to `name` in the global\n   *        context.\n   *\n   * @example\n   *\n   *   Sugar.createNamespace('Boolean');\n   *\n   * @param {string} name - The namespace name.\n   *\n   ***/\n  function createNamespace(name) {\n    // Is the current namespace Object?\n    var isObject = name === 'Object';\n\n    // A Sugar namespace is also a chainable class: Sugar.Array, etc.\n    var sugarNamespace = getNewChainableClass(name, true);\n\n    /***\n     * @method extend([opts])\n     * @returns Sugar\n     * @namespace Sugar\n     * @short Extends Sugar defined methods onto natives.\n     * @extra This method can be called on individual namespaces like\n     *        `Sugar.Array` or on the `Sugar` global itself, in which case\n     *        [opts] will be forwarded to each `extend` call. For more,\n     *        see `extending`.\n     *\n     * @options\n     *\n     *   methods           An array of method names to explicitly extend.\n     *\n     *   except            An array of method names or global namespaces (`Array`,\n     *                     `String`) to explicitly exclude. Namespaces should be the\n     *                     actual global objects, not strings.\n     *\n     *   namespaces        An array of global namespaces (`Array`, `String`) to\n     *                     explicitly extend. Namespaces should be the actual\n     *                     global objects, not strings.\n     *\n     *   enhance           A shortcut to disallow all \"enhance\" flags at once\n     *                     (flags listed below). For more, see `enhanced methods`.\n     *                     Default is `true`.\n     *\n     *   enhanceString     A boolean allowing String enhancements. Default is `true`.\n     *\n     *   enhanceArray      A boolean allowing Array enhancements. Default is `true`.\n     *\n     *   objectPrototype   A boolean allowing Sugar to extend Object.prototype\n     *                     with instance methods. This option is off by default\n     *                     and should generally not be used except with caution.\n     *                     For more, see `object methods`.\n     *\n     * @example\n     *\n     *   Sugar.Array.extend();\n     *   Sugar.extend();\n     *\n     * @option {Array<string>} [methods]\n     * @option {Array<string|NativeConstructor>} [except]\n     * @option {Array<NativeConstructor>} [namespaces]\n     * @option {boolean} [enhance]\n     * @option {boolean} [enhanceString]\n     * @option {boolean} [enhanceArray]\n     * @option {boolean} [objectPrototype]\n     * @param {ExtendOptions} [opts]\n     *\n     ***\n     * @method extend([opts])\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Extends Sugar defined methods for a specific namespace onto natives.\n     * @param {ExtendOptions} [opts]\n     *\n     ***/\n    var extend = function (opts) {\n      var nativeClass = globalContext[name],\n        nativeProto = nativeClass.prototype;\n      var staticMethods = {},\n        instanceMethods = {},\n        methodsByName;\n      function objectRestricted(name, target) {\n        return isObject && target === nativeProto && (!allowObjectPrototype || name === 'get' || name === 'set');\n      }\n      function arrayOptionExists(field, val) {\n        var arr = opts[field];\n        if (arr) {\n          for (var i = 0, el; el = arr[i]; i++) {\n            if (el === val) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      function arrayOptionExcludes(field, val) {\n        return opts[field] && !arrayOptionExists(field, val);\n      }\n      function disallowedByFlags(methodName, target, flags) {\n        // Disallowing methods by flag currently only applies if methods already\n        // exist to avoid enhancing native methods, as aliases should still be\n        // extended (i.e. Array#all should still be extended even if Array#every\n        // is being disallowed by a flag).\n        if (!target[methodName] || !flags) {\n          return false;\n        }\n        for (var i = 0; i < flags.length; i++) {\n          if (opts[flags[i]] === false) {\n            return true;\n          }\n        }\n      }\n      function namespaceIsExcepted() {\n        return arrayOptionExists('except', nativeClass) || arrayOptionExcludes('namespaces', nativeClass);\n      }\n      function methodIsExcepted(methodName) {\n        return arrayOptionExists('except', methodName);\n      }\n      function canExtend(methodName, method, target) {\n        return !objectRestricted(methodName, target) && !disallowedByFlags(methodName, target, method.flags) && !methodIsExcepted(methodName);\n      }\n      opts = opts || {};\n      methodsByName = opts.methods;\n      if (namespaceIsExcepted()) {\n        return;\n      } else if (isObject && typeof opts.objectPrototype === 'boolean') {\n        // Store \"objectPrototype\" flag for future reference.\n        allowObjectPrototype = opts.objectPrototype;\n      }\n      forEachProperty(methodsByName || sugarNamespace, function (method, methodName) {\n        if (methodsByName) {\n          // If we have method names passed in an array,\n          // then we need to flip the key and value here\n          // and find the method in the Sugar namespace.\n          methodName = method;\n          method = sugarNamespace[methodName];\n        }\n        if (hasOwn(method, 'instance') && canExtend(methodName, method, nativeProto)) {\n          instanceMethods[methodName] = method.instance;\n        }\n        if (hasOwn(method, 'static') && canExtend(methodName, method, nativeClass)) {\n          staticMethods[methodName] = method;\n        }\n      });\n\n      // Accessing the extend target each time instead of holding a reference as\n      // it may have been overwritten (for example Date by Sinon). Also need to\n      // access through the global to allow extension of user-defined namespaces.\n      extendNative(nativeClass, staticMethods);\n      extendNative(nativeProto, instanceMethods);\n      if (!methodsByName) {\n        // If there are no method names passed, then\n        // all methods in the namespace will be extended\n        // to the native. This includes all future defined\n        // methods, so add a flag here to check later.\n        setProperty(sugarNamespace, 'active', true);\n      }\n      return sugarNamespace;\n    };\n    function defineWithOptionCollect(methodName, instance, args) {\n      setProperty(sugarNamespace, methodName, function (arg1, arg2, arg3) {\n        var opts = collectDefineOptions(arg1, arg2, arg3);\n        defineMethods(sugarNamespace, opts.methods, instance, args, opts.last);\n        return sugarNamespace;\n      });\n    }\n\n    /***\n     * @method defineStatic(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines static methods on the namespace that can later be extended\n     *        onto the native globals.\n     * @extra Accepts either a single object mapping names to functions, or name\n     *        and function as two arguments. If `extend` was previously called\n     *        with no arguments, the method will be immediately mapped to its\n     *        native when defined.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineStatic({\n     *     isOdd: function (num) {\n     *       return num % 2 === 1;\n     *     }\n     *   });\n     *\n     * @signature defineStatic(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineStatic', STATIC);\n\n    /***\n     * @method defineInstance(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines methods on the namespace that can later be extended as\n     *        instance methods onto the native prototype.\n     * @extra Accepts either a single object mapping names to functions, or name\n     *        and function as two arguments. All functions should accept the\n     *        native for which they are mapped as their first argument, and should\n     *        never refer to `this`. If `extend` was previously called with no\n     *        arguments, the method will be immediately mapped to its native when\n     *        defined.\n     *\n     *        Methods cannot accept more than 4 arguments in addition to the\n     *        native (5 arguments total). Any additional arguments will not be\n     *        mapped. If the method needs to accept unlimited arguments, use\n     *        `defineInstanceWithArguments`. Otherwise if more options are\n     *        required, use an options object instead.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineInstance({\n     *     square: function (num) {\n     *       return num * num;\n     *     }\n     *   });\n     *\n     * @signature defineInstance(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineInstance', INSTANCE);\n\n    /***\n     * @method defineInstanceAndStatic(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short A shortcut to define both static and instance methods on the namespace.\n     * @extra This method is intended for use with `Object` instance methods. Sugar\n     *        will not map any methods to `Object.prototype` by default, so defining\n     *        instance methods as static helps facilitate their proper use.\n     *\n     * @example\n     *\n     *   Sugar.Object.defineInstanceAndStatic({\n     *     isAwesome: function (obj) {\n     *       // check if obj is awesome!\n     *     }\n     *   });\n     *\n     * @signature defineInstanceAndStatic(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineInstanceAndStatic', INSTANCE | STATIC);\n\n    /***\n     * @method defineStaticWithArguments(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines static methods that collect arguments.\n     * @extra This method is identical to `defineStatic`, except that when defined\n     *        methods are called, they will collect any arguments past `n - 1`,\n     *        where `n` is the number of arguments that the method accepts.\n     *        Collected arguments will be passed to the method in an array\n     *        as the last argument defined on the function.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineStaticWithArguments({\n     *     addAll: function (num, args) {\n     *       for (var i = 0; i < args.length; i++) {\n     *         num += args[i];\n     *       }\n     *       return num;\n     *     }\n     *   });\n     *\n     * @signature defineStaticWithArguments(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineStaticWithArguments', STATIC, true);\n\n    /***\n     * @method defineInstanceWithArguments(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines instance methods that collect arguments.\n     * @extra This method is identical to `defineInstance`, except that when\n     *        defined methods are called, they will collect any arguments past\n     *        `n - 1`, where `n` is the number of arguments that the method\n     *        accepts. Collected arguments will be passed to the method as the\n     *        last argument defined on the function.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineInstanceWithArguments({\n     *     addAll: function (num, args) {\n     *       for (var i = 0; i < args.length; i++) {\n     *         num += args[i];\n     *       }\n     *       return num;\n     *     }\n     *   });\n     *\n     * @signature defineInstanceWithArguments(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineInstanceWithArguments', INSTANCE, true);\n\n    /***\n     * @method defineStaticPolyfill(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines static methods that are mapped onto the native if they do\n     *        not already exist.\n     * @extra Intended only for use creating polyfills that follow the ECMAScript\n     *        spec. Accepts either a single object mapping names to functions, or\n     *        name and function as two arguments. Note that polyfill methods will\n     *        be immediately mapped onto their native prototype regardless of the\n     *        use of `extend`.\n     *\n     * @example\n     *\n     *   Sugar.Object.defineStaticPolyfill({\n     *     keys: function (obj) {\n     *       // get keys!\n     *     }\n     *   });\n     *\n     * @signature defineStaticPolyfill(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    setProperty(sugarNamespace, 'defineStaticPolyfill', function (arg1, arg2, arg3) {\n      var opts = collectDefineOptions(arg1, arg2, arg3);\n      extendNative(globalContext[name], opts.methods, true, opts.last);\n      return sugarNamespace;\n    });\n\n    /***\n     * @method defineInstancePolyfill(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines instance methods that are mapped onto the native prototype\n     *        if they do not already exist.\n     * @extra Intended only for use creating polyfills that follow the ECMAScript\n     *        spec. Accepts either a single object mapping names to functions, or\n     *        name and function as two arguments. This method differs from\n     *        `defineInstance` as there is no static signature (as the method\n     *        is mapped as-is to the native), so it should refer to its `this`\n     *        object. Note that polyfill methods will be immediately mapped onto\n     *        their native prototype regardless of the use of `extend`.\n     *\n     * @example\n     *\n     *   Sugar.Array.defineInstancePolyfill({\n     *     indexOf: function (arr, el) {\n     *       // index finding code here!\n     *     }\n     *   });\n     *\n     * @signature defineInstancePolyfill(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    setProperty(sugarNamespace, 'defineInstancePolyfill', function (arg1, arg2, arg3) {\n      var opts = collectDefineOptions(arg1, arg2, arg3);\n      extendNative(globalContext[name].prototype, opts.methods, true, opts.last);\n      // Map instance polyfills to chainable as well.\n      forEachProperty(opts.methods, function (fn, methodName) {\n        defineChainableMethod(sugarNamespace, methodName, fn);\n      });\n      return sugarNamespace;\n    });\n\n    /***\n     * @method alias(toName, from)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Aliases one Sugar method to another.\n     *\n     * @example\n     *\n     *   Sugar.Array.alias('all', 'every');\n     *\n     * @signature alias(toName, fn)\n     * @param {string} toName - Name for new method.\n     * @param {string|Function} from - Method to alias, or string shortcut.\n     ***/\n    setProperty(sugarNamespace, 'alias', function (name, source) {\n      var method = typeof source === 'string' ? sugarNamespace[source] : source;\n      setMethod(sugarNamespace, name, method);\n      return sugarNamespace;\n    });\n\n    // Each namespace can extend only itself through its .extend method.\n    setProperty(sugarNamespace, 'extend', extend);\n\n    // Cache the class to namespace relationship for later use.\n    namespacesByName[name] = sugarNamespace;\n    namespacesByClassString['[object ' + name + ']'] = sugarNamespace;\n    mapNativeToChainable(name);\n    mapObjectChainablesToNamespace(sugarNamespace);\n\n    // Export\n    return Sugar[name] = sugarNamespace;\n  }\n  function setGlobalProperties() {\n    setProperty(Sugar, 'VERSION', '2.0.6');\n    setProperty(Sugar, 'extend', Sugar);\n    setProperty(Sugar, 'toString', toString);\n    setProperty(Sugar, 'createNamespace', createNamespace);\n    setProperty(Sugar, 'util', {\n      'hasOwn': hasOwn,\n      'getOwn': getOwn,\n      'setProperty': setProperty,\n      'classToString': classToString,\n      'defineProperty': defineProperty,\n      'forEachProperty': forEachProperty,\n      'mapNativeToChainable': mapNativeToChainable\n    });\n  }\n  function toString() {\n    return SUGAR_GLOBAL;\n  }\n\n  // Defining Methods\n\n  function defineMethods(sugarNamespace, methods, type, args, flags) {\n    forEachProperty(methods, function (method, methodName) {\n      var instanceMethod,\n        staticMethod = method;\n      if (args) {\n        staticMethod = wrapMethodWithArguments(method);\n      }\n      if (flags) {\n        staticMethod.flags = flags;\n      }\n\n      // A method may define its own custom implementation, so\n      // make sure that's not the case before creating one.\n      if (type & INSTANCE && !method.instance) {\n        instanceMethod = wrapInstanceMethod(method, args);\n        setProperty(staticMethod, 'instance', instanceMethod);\n      }\n      if (type & STATIC) {\n        setProperty(staticMethod, 'static', true);\n      }\n      setMethod(sugarNamespace, methodName, staticMethod);\n      if (sugarNamespace.active) {\n        // If the namespace has been activated (.extend has been called),\n        // then map this method as well.\n        sugarNamespace.extend(methodName);\n      }\n    });\n  }\n  function collectDefineOptions(arg1, arg2, arg3) {\n    var methods, last;\n    if (typeof arg1 === 'string') {\n      methods = {};\n      methods[arg1] = arg2;\n      last = arg3;\n    } else {\n      methods = arg1;\n      last = arg2;\n    }\n    return {\n      last: last,\n      methods: methods\n    };\n  }\n  function wrapInstanceMethod(fn, args) {\n    return args ? wrapMethodWithArguments(fn, true) : wrapInstanceMethodFixed(fn);\n  }\n  function wrapMethodWithArguments(fn, instance) {\n    // Functions accepting enumerated arguments will always have \"args\" as the\n    // last argument, so subtract one from the function length to get the point\n    // at which to start collecting arguments. If this is an instance method on\n    // a prototype, then \"this\" will be pushed into the arguments array so start\n    // collecting 1 argument earlier.\n    var startCollect = fn.length - 1 - (instance ? 1 : 0);\n    return function () {\n      var args = [],\n        collectedArgs = [],\n        len;\n      if (instance) {\n        args.push(this);\n      }\n      len = Math.max(arguments.length, startCollect);\n      // Optimized: no leaking arguments\n      for (var i = 0; i < len; i++) {\n        if (i < startCollect) {\n          args.push(arguments[i]);\n        } else {\n          collectedArgs.push(arguments[i]);\n        }\n      }\n      args.push(collectedArgs);\n      return fn.apply(this, args);\n    };\n  }\n  function wrapInstanceMethodFixed(fn) {\n    switch (fn.length) {\n      // Wrapped instance methods will always be passed the instance\n      // as the first argument, but requiring the argument to be defined\n      // may cause confusion here, so return the same wrapped function regardless.\n      case 0:\n      case 1:\n        return function () {\n          return fn(this);\n        };\n      case 2:\n        return function (a) {\n          return fn(this, a);\n        };\n      case 3:\n        return function (a, b) {\n          return fn(this, a, b);\n        };\n      case 4:\n        return function (a, b, c) {\n          return fn(this, a, b, c);\n        };\n      case 5:\n        return function (a, b, c, d) {\n          return fn(this, a, b, c, d);\n        };\n    }\n  }\n\n  // Method helpers\n\n  function extendNative(target, source, polyfill, override) {\n    forEachProperty(source, function (method, name) {\n      if (polyfill && !override && target[name]) {\n        // Method exists, so bail.\n        return;\n      }\n      setProperty(target, name, method);\n    });\n  }\n  function setMethod(sugarNamespace, methodName, method) {\n    sugarNamespace[methodName] = method;\n    if (method.instance) {\n      defineChainableMethod(sugarNamespace, methodName, method.instance, true);\n    }\n  }\n\n  // Chainables\n\n  function getNewChainableClass(name) {\n    var fn = function SugarChainable(obj, arg) {\n      if (!(this instanceof fn)) {\n        return new fn(obj, arg);\n      }\n      if (this.constructor !== fn) {\n        // Allow modules to define their own constructors.\n        obj = this.constructor.apply(obj, arguments);\n      }\n      this.raw = obj;\n    };\n    setProperty(fn, 'toString', function () {\n      return SUGAR_GLOBAL + name;\n    });\n    setProperty(fn.prototype, 'valueOf', function () {\n      return this.raw;\n    });\n    return fn;\n  }\n  function defineChainableMethod(sugarNamespace, methodName, fn) {\n    var wrapped = wrapWithChainableResult(fn),\n      existing,\n      collision,\n      dcp;\n    dcp = DefaultChainable.prototype;\n    existing = dcp[methodName];\n\n    // If the method was previously defined on the default chainable, then a\n    // collision exists, so set the method to a disambiguation function that will\n    // lazily evaluate the object and find it's associated chainable. An extra\n    // check is required to avoid false positives from Object inherited methods.\n    collision = existing && existing !== Object.prototype[methodName];\n\n    // The disambiguation function is only required once.\n    if (!existing || !existing.disambiguate) {\n      dcp[methodName] = collision ? disambiguateMethod(methodName) : wrapped;\n    }\n\n    // The target chainable always receives the wrapped method. Additionally,\n    // if the target chainable is Sugar.Object, then map the wrapped method\n    // to all other namespaces as well if they do not define their own method\n    // of the same name. This way, a Sugar.Number will have methods like\n    // isEqual that can be called on any object without having to traverse up\n    // the prototype chain and perform disambiguation, which costs cycles.\n    // Note that the \"if\" block below actually does nothing on init as Object\n    // goes first and no other namespaces exist yet. However it needs to be\n    // here as Object instance methods defined later also need to be mapped\n    // back onto existing namespaces.\n    sugarNamespace.prototype[methodName] = wrapped;\n    if (sugarNamespace === Sugar.Object) {\n      mapObjectChainableToAllNamespaces(methodName, wrapped);\n    }\n  }\n  function mapObjectChainablesToNamespace(sugarNamespace) {\n    forEachProperty(Sugar.Object && Sugar.Object.prototype, function (val, methodName) {\n      if (typeof val === 'function') {\n        setObjectChainableOnNamespace(sugarNamespace, methodName, val);\n      }\n    });\n  }\n  function mapObjectChainableToAllNamespaces(methodName, fn) {\n    forEachProperty(namespacesByName, function (sugarNamespace) {\n      setObjectChainableOnNamespace(sugarNamespace, methodName, fn);\n    });\n  }\n  function setObjectChainableOnNamespace(sugarNamespace, methodName, fn) {\n    var proto = sugarNamespace.prototype;\n    if (!hasOwn(proto, methodName)) {\n      proto[methodName] = fn;\n    }\n  }\n  function wrapWithChainableResult(fn) {\n    return function () {\n      return new DefaultChainable(fn.apply(this.raw, arguments));\n    };\n  }\n  function disambiguateMethod(methodName) {\n    var fn = function () {\n      var raw = this.raw,\n        sugarNamespace;\n      if (raw != null) {\n        // Find the Sugar namespace for this unknown.\n        sugarNamespace = namespacesByClassString[classToString(raw)];\n      }\n      if (!sugarNamespace) {\n        // If no sugarNamespace can be resolved, then default\n        // back to Sugar.Object so that undefined and other\n        // non-supported types can still have basic object\n        // methods called on them, such as type checks.\n        sugarNamespace = Sugar.Object;\n      }\n      return new sugarNamespace(raw)[methodName].apply(this, arguments);\n    };\n    fn.disambiguate = true;\n    return fn;\n  }\n  function mapNativeToChainable(name, methodNames) {\n    var sugarNamespace = namespacesByName[name],\n      nativeProto = globalContext[name].prototype;\n    if (!methodNames && ownPropertyNames) {\n      methodNames = ownPropertyNames(nativeProto);\n    }\n    forEachProperty(methodNames, function (methodName) {\n      if (nativeMethodProhibited(methodName)) {\n        // Sugar chainables have their own constructors as well as \"valueOf\"\n        // methods, so exclude them here. The __proto__ argument should be trapped\n        // by the function check below, however simply accessing this property on\n        // Object.prototype causes QML to segfault, so pre-emptively excluding it.\n        return;\n      }\n      try {\n        var fn = nativeProto[methodName];\n        if (typeof fn !== 'function') {\n          // Bail on anything not a function.\n          return;\n        }\n      } catch (e) {\n        // Function.prototype has properties that\n        // will throw errors when accessed.\n        return;\n      }\n      defineChainableMethod(sugarNamespace, methodName, fn);\n    });\n  }\n  function nativeMethodProhibited(methodName) {\n    return methodName === 'constructor' || methodName === 'valueOf' || methodName === '__proto__';\n  }\n\n  // Util\n\n  // Internal references\n  var ownPropertyNames = Object.getOwnPropertyNames,\n    internalToString = Object.prototype.toString,\n    internalHasOwnProperty = Object.prototype.hasOwnProperty;\n\n  // Defining this as a variable here as the ES5 module\n  // overwrites it to patch DONTENUM.\n  var forEachProperty = function (obj, fn) {\n    for (var key in obj) {\n      if (!hasOwn(obj, key)) continue;\n      if (fn.call(obj, obj[key], key, obj) === false) break;\n    }\n  };\n\n  // istanbul ignore next\n  function definePropertyShim(obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n  }\n  function setProperty(target, name, value, enumerable) {\n    defineProperty(target, name, {\n      value: value,\n      enumerable: !!enumerable,\n      configurable: true,\n      writable: true\n    });\n  }\n\n  // PERF: Attempts to speed this method up get very Heisenbergy. Quickly\n  // returning based on typeof works for primitives, but slows down object\n  // types. Even === checks on null and undefined (no typeof) will end up\n  // basically breaking even. This seems to be as fast as it can go.\n  function classToString(obj) {\n    return internalToString.call(obj);\n  }\n  function hasOwn(obj, prop) {\n    return !!obj && internalHasOwnProperty.call(obj, prop);\n  }\n  function getOwn(obj, prop) {\n    if (hasOwn(obj, prop)) {\n      return obj[prop];\n    }\n  }\n  setupGlobal();\n\n  /***\n   * @module Common\n   * @description Internal utility and common methods.\n   ***/\n\n  // Flag allowing native methods to be enhanced.\n  var ENHANCEMENTS_FLAG = 'enhance';\n\n  // For type checking, etc. Excludes object as this is more nuanced.\n  var NATIVE_TYPES = 'Boolean Number String Date RegExp Function Array Error Set Map';\n\n  // Do strings have no keys?\n  var NO_KEYS_IN_STRING_OBJECTS = !('0' in Object('a'));\n\n  // Prefix for private properties.\n  var PRIVATE_PROP_PREFIX = '_sugar_';\n\n  // Matches 1..2 style ranges in properties.\n  var PROPERTY_RANGE_REG = /^(.*?)\\[([-\\d]*)\\.\\.([-\\d]*)\\](.*)$/;\n\n  // WhiteSpace/LineTerminator as defined in ES5.1 plus Unicode characters in the Space, Separator category.\n  var TRIM_CHARS = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF';\n\n  // Regex for matching a formatted string.\n  var STRING_FORMAT_REG = /([{}])\\1|{([^}]*)}|(%)%|(%(\\w*))/g;\n\n  // Common chars\n  var HALF_WIDTH_ZERO = 0x30,\n    FULL_WIDTH_ZERO = 0xff10,\n    HALF_WIDTH_PERIOD = '.',\n    FULL_WIDTH_PERIOD = '．',\n    HALF_WIDTH_COMMA = ',',\n    OPEN_BRACE = '{',\n    CLOSE_BRACE = '}';\n\n  // Namespace aliases\n  var sugarObject = Sugar.Object,\n    sugarArray = Sugar.Array,\n    sugarDate = Sugar.Date,\n    sugarString = Sugar.String,\n    sugarNumber = Sugar.Number,\n    sugarFunction = Sugar.Function,\n    sugarRegExp = Sugar.RegExp;\n\n  // Class checks\n  var isSerializable, isBoolean, isNumber, isString, isDate, isRegExp, isFunction, isArray, isSet, isMap, isError;\n  function buildClassChecks() {\n    var knownTypes = {};\n    function addCoreTypes() {\n      var names = spaceSplit(NATIVE_TYPES);\n      isBoolean = buildPrimitiveClassCheck(names[0]);\n      isNumber = buildPrimitiveClassCheck(names[1]);\n      isString = buildPrimitiveClassCheck(names[2]);\n      isDate = buildClassCheck(names[3]);\n      isRegExp = buildClassCheck(names[4]);\n\n      // Wanted to enhance performance here by using simply \"typeof\"\n      // but Firefox has two major issues that make this impossible,\n      // one fixed, the other not, so perform a full class check here.\n      //\n      // 1. Regexes can be typeof \"function\" in FF < 3\n      //    https://bugzilla.mozilla.org/show_bug.cgi?id=61911 (fixed)\n      //\n      // 2. HTMLEmbedElement and HTMLObjectElement are be typeof \"function\"\n      //    https://bugzilla.mozilla.org/show_bug.cgi?id=268945 (won't fix)\n      isFunction = buildClassCheck(names[5]);\n\n      // istanbul ignore next\n      isArray = Array.isArray || buildClassCheck(names[6]);\n      isError = buildClassCheck(names[7]);\n      isSet = buildClassCheck(names[8], typeof Set !== 'undefined' && Set);\n      isMap = buildClassCheck(names[9], typeof Map !== 'undefined' && Map);\n\n      // Add core types as known so that they can be checked by value below,\n      // notably excluding Functions and adding Arguments and Error.\n      addKnownType('Arguments');\n      addKnownType(names[0]);\n      addKnownType(names[1]);\n      addKnownType(names[2]);\n      addKnownType(names[3]);\n      addKnownType(names[4]);\n      addKnownType(names[6]);\n    }\n    function addArrayTypes() {\n      var types = 'Int8 Uint8 Uint8Clamped Int16 Uint16 Int32 Uint32 Float32 Float64';\n      forEach(spaceSplit(types), function (str) {\n        addKnownType(str + 'Array');\n      });\n    }\n    function addKnownType(className) {\n      var str = '[object ' + className + ']';\n      knownTypes[str] = true;\n    }\n    function isKnownType(className) {\n      return knownTypes[className];\n    }\n    function buildClassCheck(className, globalObject) {\n      // istanbul ignore if\n      if (globalObject && isClass(new globalObject(), 'Object')) {\n        return getConstructorClassCheck(globalObject);\n      } else {\n        return getToStringClassCheck(className);\n      }\n    }\n\n    // Map and Set may be [object Object] in certain IE environments.\n    // In this case we need to perform a check using the constructor\n    // instead of Object.prototype.toString.\n    // istanbul ignore next\n    function getConstructorClassCheck(obj) {\n      var ctorStr = String(obj);\n      return function (obj) {\n        return String(obj.constructor) === ctorStr;\n      };\n    }\n    function getToStringClassCheck(className) {\n      return function (obj, str) {\n        // perf: Returning up front on instanceof appears to be slower.\n        return isClass(obj, className, str);\n      };\n    }\n    function buildPrimitiveClassCheck(className) {\n      var type = className.toLowerCase();\n      return function (obj) {\n        var t = typeof obj;\n        return t === type || t === 'object' && isClass(obj, className);\n      };\n    }\n    addCoreTypes();\n    addArrayTypes();\n    isSerializable = function (obj, className) {\n      // Only known objects can be serialized. This notably excludes functions,\n      // host objects, Symbols (which are matched by reference), and instances\n      // of classes. The latter can arguably be matched by value, but\n      // distinguishing between these and host objects -- which should never be\n      // compared by value -- is very tricky so not dealing with it here.\n      return isKnownType(className) || isPlainObject(obj, className);\n    };\n  }\n  function isClass(obj, className, str) {\n    if (!str) {\n      str = classToString(obj);\n    }\n    return str === '[object ' + className + ']';\n  }\n\n  // Wrapping the core's \"define\" methods to\n  // save a few bytes in the minified script.\n  function wrapNamespace(method) {\n    return function (sugarNamespace, arg1, arg2) {\n      sugarNamespace[method](arg1, arg2);\n    };\n  }\n\n  // Method define aliases\n  var alias = wrapNamespace('alias'),\n    defineStatic = wrapNamespace('defineStatic'),\n    defineInstance = wrapNamespace('defineInstance'),\n    defineStaticPolyfill = wrapNamespace('defineStaticPolyfill'),\n    defineInstancePolyfill = wrapNamespace('defineInstancePolyfill'),\n    defineInstanceAndStatic = wrapNamespace('defineInstanceAndStatic'),\n    defineInstanceWithArguments = wrapNamespace('defineInstanceWithArguments');\n  function defineInstanceSimilar(sugarNamespace, set, fn, flags) {\n    defineInstance(sugarNamespace, collectSimilarMethods(set, fn), flags);\n  }\n  function defineInstanceAndStaticSimilar(sugarNamespace, set, fn, flags) {\n    defineInstanceAndStatic(sugarNamespace, collectSimilarMethods(set, fn), flags);\n  }\n  function collectSimilarMethods(set, fn) {\n    var methods = {};\n    if (isString(set)) {\n      set = spaceSplit(set);\n    }\n    forEach(set, function (el, i) {\n      fn(methods, el, i);\n    });\n    return methods;\n  }\n\n  // This song and dance is to fix methods to a different length\n  // from what they actually accept in order to stay in line with\n  // spec. Additionally passing argument length, as some methods\n  // throw assertion errors based on this (undefined check is not\n  // enough). Fortunately for now spec is such that passing 3\n  // actual arguments covers all requirements. Note that passing\n  // the argument length also forces the compiler to not rewrite\n  // length of the compiled function.\n  function fixArgumentLength(fn) {\n    var staticFn = function (a) {\n      var args = arguments;\n      return fn(a, args[1], args[2], args.length - 1);\n    };\n    staticFn.instance = function (b) {\n      var args = arguments;\n      return fn(this, b, args[1], args.length);\n    };\n    return staticFn;\n  }\n  function defineAccessor(namespace, name, fn) {\n    setProperty(namespace, name, fn);\n  }\n  function defineOptionsAccessor(namespace, defaults) {\n    var obj = simpleClone(defaults);\n    function getOption(name) {\n      return obj[name];\n    }\n    function setOption(arg1, arg2) {\n      var options;\n      if (arguments.length === 1) {\n        options = arg1;\n      } else {\n        options = {};\n        options[arg1] = arg2;\n      }\n      forEachProperty(options, function (val, name) {\n        if (val === null) {\n          val = defaults[name];\n        }\n        obj[name] = val;\n      });\n    }\n    defineAccessor(namespace, 'getOption', getOption);\n    defineAccessor(namespace, 'setOption', setOption);\n    return getOption;\n  }\n\n  // For methods defined directly on the prototype like Range\n  function defineOnPrototype(ctor, methods) {\n    var proto = ctor.prototype;\n    forEachProperty(methods, function (val, key) {\n      proto[key] = val;\n    });\n  }\n\n  // Argument helpers\n\n  function assertArgument(exists) {\n    if (!exists) {\n      throw new TypeError('Argument required');\n    }\n  }\n  function assertCallable(obj) {\n    if (!isFunction(obj)) {\n      throw new TypeError('Function is not callable');\n    }\n  }\n  function assertArray(obj) {\n    if (!isArray(obj)) {\n      throw new TypeError('Array required');\n    }\n  }\n  function assertWritable(obj) {\n    if (isPrimitive(obj)) {\n      // If strict mode is active then primitives will throw an\n      // error when attempting to write properties. We can't be\n      // sure if strict mode is available, so pre-emptively\n      // throw an error here to ensure consistent behavior.\n      throw new TypeError('Property cannot be written');\n    }\n  }\n\n  // Coerces an object to a positive integer.\n  // Does not allow Infinity.\n  function coercePositiveInteger(n) {\n    n = +n || 0;\n    if (n < 0 || !isNumber(n) || !isFinite(n)) {\n      throw new RangeError('Invalid number');\n    }\n    return trunc(n);\n  }\n\n  // General helpers\n\n  function isDefined(o) {\n    return o !== undefined;\n  }\n  function isUndefined(o) {\n    return o === undefined;\n  }\n  function privatePropertyAccessor(key) {\n    var privateKey = PRIVATE_PROP_PREFIX + key;\n    return function (obj, val) {\n      if (arguments.length > 1) {\n        setProperty(obj, privateKey, val);\n        return obj;\n      }\n      return obj[privateKey];\n    };\n  }\n  function setChainableConstructor(sugarNamespace, createFn) {\n    sugarNamespace.prototype.constructor = function () {\n      return createFn.apply(this, arguments);\n    };\n  }\n\n  // Fuzzy matching helpers\n\n  function getMatcher(f) {\n    if (!isPrimitive(f)) {\n      var className = classToString(f);\n      if (isRegExp(f, className)) {\n        return regexMatcher(f);\n      } else if (isDate(f, className)) {\n        return dateMatcher(f);\n      } else if (isFunction(f, className)) {\n        return functionMatcher(f);\n      } else if (isPlainObject(f, className)) {\n        return fuzzyMatcher(f);\n      }\n    }\n    // Default is standard isEqual\n    return defaultMatcher(f);\n  }\n  function fuzzyMatcher(obj) {\n    var matchers = {};\n    return function (el, i, arr) {\n      var matched = true;\n      if (!isObjectType(el)) {\n        return false;\n      }\n      forEachProperty(obj, function (val, key) {\n        matchers[key] = getOwn(matchers, key) || getMatcher(val);\n        if (matchers[key].call(arr, el[key], i, arr) === false) {\n          matched = false;\n        }\n        return matched;\n      });\n      return matched;\n    };\n  }\n  function defaultMatcher(f) {\n    return function (el) {\n      return isEqual(el, f);\n    };\n  }\n  function regexMatcher(reg) {\n    reg = RegExp(reg);\n    return function (el) {\n      return reg.test(el);\n    };\n  }\n  function dateMatcher(d) {\n    var ms = d.getTime();\n    return function (el) {\n      return !!(el && el.getTime) && el.getTime() === ms;\n    };\n  }\n  function functionMatcher(fn) {\n    return function (el, i, arr) {\n      // Return true up front if match by reference\n      return el === fn || fn.call(arr, el, i, arr);\n    };\n  }\n\n  // Object helpers\n\n  function getKeys(obj) {\n    return Object.keys(obj);\n  }\n  function deepHasProperty(obj, key, any) {\n    return handleDeepProperty(obj, key, any, true);\n  }\n  function deepGetProperty(obj, key, any) {\n    return handleDeepProperty(obj, key, any, false);\n  }\n  function deepSetProperty(obj, key, val) {\n    handleDeepProperty(obj, key, false, false, true, false, val);\n    return obj;\n  }\n  function handleDeepProperty(obj, key, any, has, fill, fillLast, val) {\n    var ns, bs, ps, cbi, set, isLast, isPush, isIndex, nextIsIndex, exists;\n    ns = obj;\n    if (key == null) return;\n    if (isObjectType(key)) {\n      // Allow array and array-like accessors\n      bs = [key];\n    } else {\n      key = String(key);\n      if (key.indexOf('..') !== -1) {\n        return handleArrayIndexRange(obj, key, any, val);\n      }\n      bs = key.split('[');\n    }\n    set = isDefined(val);\n    for (var i = 0, blen = bs.length; i < blen; i++) {\n      ps = bs[i];\n      if (isString(ps)) {\n        ps = periodSplit(ps);\n      }\n      for (var j = 0, plen = ps.length; j < plen; j++) {\n        key = ps[j];\n\n        // Is this the last key?\n        isLast = i === blen - 1 && j === plen - 1;\n\n        // Index of the closing ]\n        cbi = key.indexOf(']');\n\n        // Is the key an array index?\n        isIndex = cbi !== -1;\n\n        // Is this array push syntax \"[]\"?\n        isPush = set && cbi === 0;\n\n        // If the bracket split was successful and this is the last element\n        // in the dot split, then we know the next key will be an array index.\n        nextIsIndex = blen > 1 && j === plen - 1;\n        if (isPush) {\n          // Set the index to the end of the array\n          key = ns.length;\n        } else if (isIndex) {\n          // Remove the closing ]\n          key = key.slice(0, -1);\n        }\n\n        // If the array index is less than 0, then\n        // add its length to allow negative indexes.\n        if (isIndex && key < 0) {\n          key = +key + ns.length;\n        }\n\n        // Bracket keys may look like users[5] or just [5], so the leading\n        // characters are optional. We can enter the namespace if this is the\n        // 2nd part, if there is only 1 part, or if there is an explicit key.\n        if (i || key || blen === 1) {\n          // TODO: need to be sure this check handles ''.length when\n          // we refactor.\n          exists = any ? key in Object(ns) : hasOwn(ns, key);\n\n          // Non-existent namespaces are only filled if they are intermediate\n          // (not at the end) or explicitly filling the last.\n          if (fill && (!isLast || fillLast) && !exists) {\n            // For our purposes, last only needs to be an array.\n            ns = ns[key] = nextIsIndex || fillLast && isLast ? [] : {};\n            continue;\n          }\n          if (has) {\n            if (isLast || !exists) {\n              return exists;\n            }\n          } else if (set && isLast) {\n            assertWritable(ns);\n            ns[key] = val;\n          }\n          ns = exists ? ns[key] : undefined;\n        }\n      }\n    }\n    return ns;\n  }\n\n  // Get object property with support for 0..1 style range notation.\n  function handleArrayIndexRange(obj, key, any, val) {\n    var match, start, end, leading, trailing, arr, set;\n    match = key.match(PROPERTY_RANGE_REG);\n    if (!match) {\n      return;\n    }\n    set = isDefined(val);\n    leading = match[1];\n    if (leading) {\n      arr = handleDeepProperty(obj, leading, any, false, set ? true : false, true);\n    } else {\n      arr = obj;\n    }\n    assertArray(arr);\n    trailing = match[4];\n    start = match[2] ? +match[2] : 0;\n    end = match[3] ? +match[3] : arr.length;\n\n    // A range of 0..1 is inclusive, so we need to add 1 to the end. If this\n    // pushes the index from -1 to 0, then set it to the full length of the\n    // array, otherwise it will return nothing.\n    end = end === -1 ? arr.length : end + 1;\n    if (set) {\n      for (var i = start; i < end; i++) {\n        handleDeepProperty(arr, i + trailing, any, false, true, false, val);\n      }\n    } else {\n      arr = arr.slice(start, end);\n\n      // If there are trailing properties, then they need to be mapped for each\n      // element in the array.\n      if (trailing) {\n        if (trailing.charAt(0) === HALF_WIDTH_PERIOD) {\n          // Need to chomp the period if one is trailing after the range. We\n          // can't do this at the regex level because it will be required if\n          // we're setting the value as it needs to be concatentated together\n          // with the array index to be set.\n          trailing = trailing.slice(1);\n        }\n        return map(arr, function (el) {\n          return handleDeepProperty(el, trailing);\n        });\n      }\n    }\n    return arr;\n  }\n  function getOwnKey(obj, key) {\n    if (hasOwn(obj, key)) {\n      return key;\n    }\n  }\n  function hasProperty(obj, prop) {\n    return !isPrimitive(obj) && prop in obj;\n  }\n  function isObjectType(obj, type) {\n    return !!obj && (type || typeof obj) === 'object';\n  }\n  function isPrimitive(obj, type) {\n    type = type || typeof obj;\n    return obj == null || type === 'string' || type === 'number' || type === 'boolean';\n  }\n  function isPlainObject(obj, className) {\n    return isObjectType(obj) && isClass(obj, 'Object', className) && hasValidPlainObjectPrototype(obj) && hasOwnEnumeratedProperties(obj);\n  }\n  function hasValidPlainObjectPrototype(obj) {\n    var hasToString = ('toString' in obj);\n    var hasConstructor = ('constructor' in obj);\n    // An object created with Object.create(null) has no methods in the\n    // prototype chain, so check if any are missing. The additional hasToString\n    // check is for false positives on some host objects in old IE which have\n    // toString but no constructor. If the object has an inherited constructor,\n    // then check if it is Object (the \"isPrototypeOf\" tapdance here is a more\n    // robust way of ensuring this if the global has been hijacked). Note that\n    // accessing the constructor directly (without \"in\" or \"hasOwnProperty\")\n    // will throw a permissions error in IE8 on cross-domain windows.\n    return !hasConstructor && !hasToString || hasConstructor && !hasOwn(obj, 'constructor') && hasOwn(obj.constructor.prototype, 'isPrototypeOf');\n  }\n  function hasOwnEnumeratedProperties(obj) {\n    // Plain objects are generally defined as having enumerated properties\n    // all their own, however in early IE environments without defineProperty,\n    // there may also be enumerated methods in the prototype chain, so check\n    // for both of these cases.\n    var objectProto = Object.prototype;\n    for (var key in obj) {\n      var val = obj[key];\n      if (!hasOwn(obj, key) && val !== objectProto[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function simpleRepeat(n, fn) {\n    for (var i = 0; i < n; i++) {\n      fn(i);\n    }\n  }\n  function simpleClone(obj) {\n    return simpleMerge({}, obj);\n  }\n\n  // TODO: Use Object.assign here going forward.\n  function simpleMerge(target, source) {\n    forEachProperty(source, function (val, key) {\n      target[key] = val;\n    });\n    return target;\n  }\n\n  // Make primtives types like strings into objects.\n  function coercePrimitiveToObject(obj) {\n    if (isPrimitive(obj)) {\n      obj = Object(obj);\n    }\n    // istanbul ignore next\n    if (NO_KEYS_IN_STRING_OBJECTS && isString(obj)) {\n      forceStringCoercion(obj);\n    }\n    return obj;\n  }\n\n  // Force strings to have their indexes set in\n  // environments that don't do this automatically.\n  // istanbul ignore next\n  function forceStringCoercion(obj) {\n    var i = 0,\n      chr;\n    while (chr = obj.charAt(i)) {\n      obj[i++] = chr;\n    }\n  }\n\n  // Equality helpers\n\n  // Perf\n  function isEqual(a, b, stack) {\n    var aClass, bClass;\n    if (a === b) {\n      // Return quickly up front when matched by reference,\n      // but be careful about 0 !== -0.\n      return a !== 0 || 1 / a === 1 / b;\n    }\n    aClass = classToString(a);\n    bClass = classToString(b);\n    if (aClass !== bClass) {\n      return false;\n    }\n    if (isSerializable(a, aClass) && isSerializable(b, bClass)) {\n      return objectIsEqual(a, b, aClass, stack);\n    } else if (isSet(a, aClass) && isSet(b, bClass)) {\n      return a.size === b.size && isEqual(setToArray(a), setToArray(b), stack);\n    } else if (isMap(a, aClass) && isMap(b, bClass)) {\n      return a.size === b.size && isEqual(mapToArray(a), mapToArray(b), stack);\n    } else if (isError(a, aClass) && isError(b, bClass)) {\n      return a.toString() === b.toString();\n    }\n    return false;\n  }\n\n  // Perf\n  function objectIsEqual(a, b, aClass, stack) {\n    var aType = typeof a,\n      bType = typeof b,\n      propsEqual,\n      count;\n    if (aType !== bType) {\n      return false;\n    }\n    if (isObjectType(a.valueOf())) {\n      if (a.length !== b.length) {\n        // perf: Quickly returning up front for arrays.\n        return false;\n      }\n      count = 0;\n      propsEqual = true;\n      iterateWithCyclicCheck(a, false, stack, function (key, val, cyc, stack) {\n        if (!cyc && (!(key in b) || !isEqual(val, b[key], stack))) {\n          propsEqual = false;\n        }\n        count++;\n        return propsEqual;\n      });\n      if (!propsEqual || count !== getKeys(b).length) {\n        return false;\n      }\n    }\n    // Stringifying the value handles NaN, wrapped primitives, dates, and errors in one go.\n    return a.valueOf().toString() === b.valueOf().toString();\n  }\n\n  // Serializes an object in a way that will provide a token unique\n  // to the type, class, and value of an object. Host objects, class\n  // instances etc, are not serializable, and are held in an array\n  // of references that will return the index as a unique identifier\n  // for the object. This array is passed from outside so that the\n  // calling function can decide when to dispose of this array.\n  function serializeInternal(obj, refs, stack) {\n    var type = typeof obj,\n      sign = '',\n      className,\n      value,\n      ref;\n\n    // Return up front on\n    if (1 / obj === -Infinity) {\n      sign = '-';\n    }\n\n    // Return quickly for primitives to save cycles\n    if (isPrimitive(obj, type) && !isRealNaN(obj)) {\n      return type + sign + obj;\n    }\n    className = classToString(obj);\n    if (!isSerializable(obj, className)) {\n      ref = indexOf(refs, obj);\n      if (ref === -1) {\n        ref = refs.length;\n        refs.push(obj);\n      }\n      return ref;\n    } else if (isObjectType(obj)) {\n      value = serializeDeep(obj, refs, stack) + obj.toString();\n    } else if (obj.valueOf) {\n      value = obj.valueOf();\n    }\n    return type + className + sign + value;\n  }\n  function serializeDeep(obj, refs, stack) {\n    var result = '';\n    iterateWithCyclicCheck(obj, true, stack, function (key, val, cyc, stack) {\n      result += cyc ? 'CYC' : key + serializeInternal(val, refs, stack);\n    });\n    return result;\n  }\n  function iterateWithCyclicCheck(obj, sortedKeys, stack, fn) {\n    function next(val, key) {\n      var cyc = false;\n\n      // Allowing a step into the structure before triggering this check to save\n      // cycles on standard JSON structures and also to try as hard as possible to\n      // catch basic properties that may have been modified.\n      if (stack.length > 1) {\n        var i = stack.length;\n        while (i--) {\n          if (stack[i] === val) {\n            cyc = true;\n          }\n        }\n      }\n      stack.push(val);\n      fn(key, val, cyc, stack);\n      stack.pop();\n    }\n    function iterateWithSortedKeys() {\n      // Sorted keys is required for serialization, where object order\n      // does not matter but stringified order does.\n      var arr = getKeys(obj).sort(),\n        key;\n      for (var i = 0; i < arr.length; i++) {\n        key = arr[i];\n        next(obj[key], arr[i]);\n      }\n    }\n\n    // This method for checking for cyclic structures was egregiously stolen from\n    // the ingenious method by @kitcambridge from the Underscore script:\n    // https://github.com/documentcloud/underscore/issues/240\n    if (!stack) {\n      stack = [];\n    }\n    if (sortedKeys) {\n      iterateWithSortedKeys();\n    } else {\n      forEachProperty(obj, next);\n    }\n  }\n\n  // Array helpers\n\n  function isArrayIndex(n) {\n    return n >>> 0 == n && n != 0xFFFFFFFF;\n  }\n  function iterateOverSparseArray(arr, fn, fromIndex, loop) {\n    var indexes = getSparseArrayIndexes(arr, fromIndex, loop),\n      index;\n    for (var i = 0, len = indexes.length; i < len; i++) {\n      index = indexes[i];\n      fn.call(arr, arr[index], index, arr);\n    }\n    return arr;\n  }\n\n  // It's unclear whether or not sparse arrays qualify as \"simple enumerables\".\n  // If they are not, however, the wrapping function will be deoptimized, so\n  // isolate here (also to share between es5 and array modules).\n  function getSparseArrayIndexes(arr, fromIndex, loop, fromRight) {\n    var indexes = [],\n      i;\n    for (i in arr) {\n      // istanbul ignore next\n      if (isArrayIndex(i) && (loop || (fromRight ? i <= fromIndex : i >= fromIndex))) {\n        indexes.push(+i);\n      }\n    }\n    indexes.sort(function (a, b) {\n      var aLoop = a > fromIndex;\n      var bLoop = b > fromIndex;\n      // This block cannot be reached unless ES5 methods are being shimmed.\n      // istanbul ignore if\n      if (aLoop !== bLoop) {\n        return aLoop ? -1 : 1;\n      }\n      return a - b;\n    });\n    return indexes;\n  }\n  function getEntriesForIndexes(obj, find, loop, isString) {\n    var result,\n      length = obj.length;\n    if (!isArray(find)) {\n      return entryAtIndex(obj, find, length, loop, isString);\n    }\n    result = new Array(find.length);\n    forEach(find, function (index, i) {\n      result[i] = entryAtIndex(obj, index, length, loop, isString);\n    });\n    return result;\n  }\n  function getNormalizedIndex(index, length, loop) {\n    if (index && loop) {\n      index = index % length;\n    }\n    if (index < 0) index = length + index;\n    return index;\n  }\n  function entryAtIndex(obj, index, length, loop, isString) {\n    index = getNormalizedIndex(index, length, loop);\n    return isString ? obj.charAt(index) : obj[index];\n  }\n  function mapWithShortcuts(el, f, context, mapArgs) {\n    if (!f) {\n      return el;\n    } else if (f.apply) {\n      return f.apply(context, mapArgs);\n    } else if (isArray(f)) {\n      return map(f, function (m) {\n        return mapWithShortcuts(el, m, context, mapArgs);\n      });\n    } else if (isFunction(el[f])) {\n      return el[f].call(el);\n    } else {\n      return deepGetProperty(el, f, true);\n    }\n  }\n  function spaceSplit(str) {\n    return str.split(' ');\n  }\n  function commaSplit(str) {\n    return str.split(HALF_WIDTH_COMMA);\n  }\n  function periodSplit(str) {\n    return str.split(HALF_WIDTH_PERIOD);\n  }\n  function forEach(arr, fn) {\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (!(i in arr)) {\n        return iterateOverSparseArray(arr, fn, i);\n      }\n      fn(arr[i], i);\n    }\n  }\n  function filter(arr, fn) {\n    var result = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n      var el = arr[i];\n      if (i in arr && fn(el, i)) {\n        result.push(el);\n      }\n    }\n    return result;\n  }\n  function map(arr, fn) {\n    // perf: Not using fixed array len here as it may be sparse.\n    var result = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (i in arr) {\n        result.push(fn(arr[i], i));\n      }\n    }\n    return result;\n  }\n  function indexOf(arr, el) {\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (i in arr && arr[i] === el) return i;\n    }\n    return -1;\n  }\n\n  // Number helpers\n\n  // istanbul ignore next\n  var trunc = Math.trunc || function (n) {\n    if (n === 0 || !isFinite(n)) return n;\n    return n < 0 ? ceil(n) : floor(n);\n  };\n  function isRealNaN(obj) {\n    // This is only true of NaN\n    return obj != null && obj !== obj;\n  }\n  function withPrecision(val, precision, fn) {\n    var multiplier = pow(10, abs(precision || 0));\n    fn = fn || round;\n    if (precision < 0) multiplier = 1 / multiplier;\n    return fn(val * multiplier) / multiplier;\n  }\n  function padNumber(num, place, sign, base, replacement) {\n    var str = abs(num).toString(base || 10);\n    str = repeatString(replacement || '0', place - str.replace(/\\.\\d+/, '').length) + str;\n    if (sign || num < 0) {\n      str = (num < 0 ? '-' : '+') + str;\n    }\n    return str;\n  }\n  function getOrdinalSuffix(num) {\n    if (num >= 11 && num <= 13) {\n      return 'th';\n    } else {\n      switch (num % 10) {\n        case 1:\n          return 'st';\n        case 2:\n          return 'nd';\n        case 3:\n          return 'rd';\n        default:\n          return 'th';\n      }\n    }\n  }\n\n  // Fullwidth number helpers\n  var fullWidthNumberReg, fullWidthNumberMap, fullWidthNumbers;\n  function buildFullWidthNumber() {\n    var fwp = FULL_WIDTH_PERIOD,\n      hwp = HALF_WIDTH_PERIOD,\n      hwc = HALF_WIDTH_COMMA,\n      fwn = '';\n    fullWidthNumberMap = {};\n    for (var i = 0, digit; i <= 9; i++) {\n      digit = chr(i + FULL_WIDTH_ZERO);\n      fwn += digit;\n      fullWidthNumberMap[digit] = chr(i + HALF_WIDTH_ZERO);\n    }\n    fullWidthNumberMap[hwc] = '';\n    fullWidthNumberMap[fwp] = hwp;\n    // Mapping this to itself to capture it easily\n    // in stringToNumber to detect decimals later.\n    fullWidthNumberMap[hwp] = hwp;\n    fullWidthNumberReg = allCharsReg(fwn + fwp + hwc + hwp);\n    fullWidthNumbers = fwn;\n  }\n\n  // Takes into account full-width characters, commas, and decimals.\n  function stringToNumber(str, base) {\n    var sanitized, isDecimal;\n    sanitized = str.replace(fullWidthNumberReg, function (chr) {\n      var replacement = getOwn(fullWidthNumberMap, chr);\n      if (replacement === HALF_WIDTH_PERIOD) {\n        isDecimal = true;\n      }\n      return replacement;\n    });\n    return isDecimal ? parseFloat(sanitized) : parseInt(sanitized, base || 10);\n  }\n\n  // Math aliases\n  var abs = Math.abs,\n    pow = Math.pow,\n    min = Math.min,\n    max = Math.max,\n    ceil = Math.ceil,\n    floor = Math.floor,\n    round = Math.round;\n\n  // String helpers\n\n  var chr = String.fromCharCode;\n  function trim(str) {\n    return str.trim();\n  }\n  function repeatString(str, num) {\n    var result = '';\n    str = str.toString();\n    while (num > 0) {\n      if (num & 1) {\n        result += str;\n      }\n      if (num >>= 1) {\n        str += str;\n      }\n    }\n    return result;\n  }\n  function simpleCapitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n  function createFormatMatcher(bracketMatcher, percentMatcher, precheck) {\n    var reg = STRING_FORMAT_REG;\n    var compileMemoized = memoizeFunction(compile);\n    function getToken(format, match) {\n      var get, token, literal, fn;\n      var bKey = match[2];\n      var pLit = match[3];\n      var pKey = match[5];\n      if (match[4] && percentMatcher) {\n        token = pKey;\n        get = percentMatcher;\n      } else if (bKey) {\n        token = bKey;\n        get = bracketMatcher;\n      } else if (pLit && percentMatcher) {\n        literal = pLit;\n      } else {\n        literal = match[1] || match[0];\n      }\n      if (get) {\n        assertPassesPrecheck(precheck, bKey, pKey);\n        fn = function (obj, opt) {\n          return get(obj, token, opt);\n        };\n      }\n      format.push(fn || getLiteral(literal));\n    }\n    function getSubstring(format, str, start, end) {\n      if (end > start) {\n        var sub = str.slice(start, end);\n        assertNoUnmatched(sub, OPEN_BRACE);\n        assertNoUnmatched(sub, CLOSE_BRACE);\n        format.push(function () {\n          return sub;\n        });\n      }\n    }\n    function getLiteral(str) {\n      return function () {\n        return str;\n      };\n    }\n    function assertPassesPrecheck(precheck, bt, pt) {\n      if (precheck && !precheck(bt, pt)) {\n        throw new TypeError('Invalid token ' + (bt || pt) + ' in format string');\n      }\n    }\n    function assertNoUnmatched(str, chr) {\n      if (str.indexOf(chr) !== -1) {\n        throw new TypeError('Unmatched ' + chr + ' in format string');\n      }\n    }\n    function compile(str) {\n      var format = [],\n        lastIndex = 0,\n        match;\n      reg.lastIndex = 0;\n      while (match = reg.exec(str)) {\n        getSubstring(format, str, lastIndex, match.index);\n        getToken(format, match);\n        lastIndex = reg.lastIndex;\n      }\n      getSubstring(format, str, lastIndex, str.length);\n      return format;\n    }\n    return function (str, obj, opt) {\n      var format = compileMemoized(str),\n        result = '';\n      for (var i = 0; i < format.length; i++) {\n        result += format[i](obj, opt);\n      }\n      return result;\n    };\n  }\n\n  // Inflection helper\n\n  var Inflections = {};\n  function getAcronym(str) {\n    // istanbul ignore next\n    return Inflections.acronyms && Inflections.acronyms.find(str);\n  }\n  function getHumanWord(str) {\n    // istanbul ignore next\n    return Inflections.human && Inflections.human.find(str);\n  }\n  function runHumanRules(str) {\n    // istanbul ignore next\n    return Inflections.human && Inflections.human.runRules(str) || str;\n  }\n\n  // RegExp helpers\n\n  function allCharsReg(src) {\n    return RegExp('[' + src + ']', 'g');\n  }\n  function getRegExpFlags(reg, add) {\n    var flags = '';\n    add = add || '';\n    function checkFlag(prop, flag) {\n      if (prop || add.indexOf(flag) > -1) {\n        flags += flag;\n      }\n    }\n    checkFlag(reg.global, 'g');\n    checkFlag(reg.ignoreCase, 'i');\n    checkFlag(reg.multiline, 'm');\n    checkFlag(reg.sticky, 'y');\n    return flags;\n  }\n  function escapeRegExp(str) {\n    if (!isString(str)) str = String(str);\n    return str.replace(/([\\\\/'*+?|()[\\]{}.^$-])/g, '\\\\$1');\n  }\n\n  // Date helpers\n\n  var _utc = privatePropertyAccessor('utc');\n  function callDateGet(d, method) {\n    return d['get' + (_utc(d) ? 'UTC' : '') + method]();\n  }\n  function callDateSet(d, method, value, safe) {\n    // \"Safe\" denotes not setting the date if the value is the same as what is\n    // currently set. In theory this should be a noop, however it will cause\n    // timezone shifts when in the middle of a DST fallback. This is unavoidable\n    // as the notation itself is ambiguous (i.e. there are two \"1:00ams\" on\n    // November 1st, 2015 in northern hemisphere timezones that follow DST),\n    // however when advancing or rewinding dates this can throw off calculations\n    // so avoiding this unintentional shifting on an opt-in basis.\n    if (safe && value === callDateGet(d, method, value)) {\n      return;\n    }\n    d['set' + (_utc(d) ? 'UTC' : '') + method](value);\n  }\n\n  // Memoization helpers\n\n  var INTERNAL_MEMOIZE_LIMIT = 1000;\n\n  // Note that attemps to consolidate this with Function#memoize\n  // ended up clunky as that is also serializing arguments. Separating\n  // these implementations turned out to be simpler.\n  function memoizeFunction(fn) {\n    var memo = {},\n      counter = 0;\n    return function (key) {\n      if (hasOwn(memo, key)) {\n        return memo[key];\n      }\n      // istanbul ignore if\n      if (counter === INTERNAL_MEMOIZE_LIMIT) {\n        memo = {};\n        counter = 0;\n      }\n      counter++;\n      return memo[key] = fn(key);\n    };\n  }\n\n  // ES6 helpers\n\n  function setToArray(set) {\n    var arr = new Array(set.size),\n      i = 0;\n    set.forEach(function (val) {\n      arr[i++] = val;\n    });\n    return arr;\n  }\n  function mapToArray(map) {\n    var arr = new Array(map.size),\n      i = 0;\n    map.forEach(function (val, key) {\n      arr[i++] = [key, val];\n    });\n    return arr;\n  }\n  buildClassChecks();\n  buildFullWidthNumber();\n\n  /***\n   * @module ES5\n   * @description Functions and polyfill methods that fix ES5 functionality. This\n   *              module is excluded from default builds, and can be included if\n   *              you need legacy browser support (IE8 and below).\n   *\n   ***/\n\n  // Non-enumerable properties on Object.prototype. In early JScript implementations\n  // (< IE9) these will shadow object properties and break for..in loops.\n  var DONT_ENUM_PROPS = ['valueOf', 'toString', 'constructor', 'isPrototypeOf', 'hasOwnProperty', 'toLocaleString', 'propertyIsEnumerable'];\n\n  /***\n   * @fix\n   * @short Fixes DontEnum bug for iteration methods in < IE9.\n   ***/\n  function buildDontEnumFix() {\n    if (!{\n      toString: 1\n    }.propertyIsEnumerable('toString')) {\n      var forEachEnumerableProperty = forEachProperty;\n      forEachProperty = function (obj, fn) {\n        forEachEnumerableProperty(obj, fn);\n        for (var i = 0, key; key = DONT_ENUM_PROPS[i]; i++) {\n          if (hasOwn(obj, key)) {\n            if (fn.call(obj, obj[key], key, obj) === false) break;\n          }\n        }\n      };\n    }\n  }\n\n  /***\n   * @fix\n   * @short Adds native methods to chainables in < IE9.\n   ***/\n  function buildChainableNativeMethodsFix() {\n    if (!Object.getOwnPropertyNames) {\n      defineNativeMethodsOnChainable();\n    }\n  }\n\n  // Polyfilled methods will automatically be added to the chainable prototype.\n  // However, Object.getOwnPropertyNames cannot be shimmed for non-enumerable\n  // properties, so if it does not exist, then the only way to access native\n  // methods previous to ES5 is to provide them as a list of tokens here.\n  function defineNativeMethodsOnChainable() {\n    var nativeTokens = {\n      'Function': 'apply,call',\n      'RegExp': 'compile,exec,test',\n      'Number': 'toExponential,toFixed,toLocaleString,toPrecision',\n      'Object': 'hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString',\n      'Array': 'concat,join,pop,push,reverse,shift,slice,sort,splice,toLocaleString,unshift',\n      'Date': 'getTime,getTimezoneOffset,setTime,toDateString,toGMTString,toLocaleDateString,toLocaleString,toLocaleTimeString,toTimeString,toUTCString',\n      'String': 'anchor,big,blink,bold,charAt,charCodeAt,concat,fixed,fontcolor,fontsize,indexOf,italics,lastIndexOf,link,localeCompare,match,replace,search,slice,small,split,strike,sub,substr,substring,sup,toLocaleLowerCase,toLocaleUpperCase,toLowerCase,toUpperCase'\n    };\n    var dateTokens = 'FullYear,Month,Date,Hours,Minutes,Seconds,Milliseconds'.split(',');\n    function addDateTokens(prefix, arr) {\n      for (var i = 0; i < dateTokens.length; i++) {\n        arr.push(prefix + dateTokens[i]);\n      }\n    }\n    forEachProperty(nativeTokens, function (str, name) {\n      var tokens = str.split(',');\n      if (name === 'Date') {\n        addDateTokens('get', tokens);\n        addDateTokens('set', tokens);\n        addDateTokens('getUTC', tokens);\n        addDateTokens('setUTC', tokens);\n      }\n      tokens.push('toString');\n      mapNativeToChainable(name, tokens);\n    });\n  }\n  buildDontEnumFix();\n  buildChainableNativeMethodsFix();\n\n  /*** @namespace Object ***/\n\n  function assertNonNull(obj) {\n    if (obj == null) {\n      throw new TypeError('Object required');\n    }\n  }\n  defineStaticPolyfill(sugarObject, {\n    'keys': function (obj) {\n      var keys = [];\n      assertNonNull(obj);\n      forEachProperty(coercePrimitiveToObject(obj), function (val, key) {\n        keys.push(key);\n      });\n      return keys;\n    }\n  });\n\n  /*** @namespace Array ***/\n\n  function arrayIndexOf(arr, search, fromIndex, fromRight) {\n    var length = arr.length,\n      defaultFromIndex,\n      index,\n      increment;\n    increment = fromRight ? -1 : 1;\n    defaultFromIndex = fromRight ? length - 1 : 0;\n    fromIndex = trunc(fromIndex);\n    if (!fromIndex && fromIndex !== 0) {\n      fromIndex = defaultFromIndex;\n    }\n    if (fromIndex < 0) {\n      fromIndex = length + fromIndex;\n    }\n    if (!fromRight && fromIndex < 0 || fromRight && fromIndex >= length) {\n      fromIndex = defaultFromIndex;\n    }\n    index = fromIndex;\n    while (fromRight && index >= 0 || !fromRight && index < length) {\n      if (!(index in arr)) {\n        return sparseIndexOf(arr, search, fromIndex, fromRight);\n      }\n      if (isArrayIndex(index) && arr[index] === search) {\n        return index;\n      }\n      index += increment;\n    }\n    return -1;\n  }\n  function sparseIndexOf(arr, search, fromIndex, fromRight) {\n    var indexes = getSparseArrayIndexes(arr, fromIndex, false, fromRight),\n      index;\n    indexes.sort(function (a, b) {\n      return fromRight ? b - a : a - b;\n    });\n    while ((index = indexes.shift()) !== undefined) {\n      if (arr[index] === search) {\n        return +index;\n      }\n    }\n    return -1;\n  }\n  function arrayReduce(arr, fn, initialValue, fromRight) {\n    var length = arr.length,\n      count = 0,\n      defined = isDefined(initialValue),\n      result,\n      index;\n    assertCallable(fn);\n    if (length == 0 && !defined) {\n      throw new TypeError('Reduce called on empty array with no initial value');\n    } else if (defined) {\n      result = initialValue;\n    } else {\n      result = arr[fromRight ? length - 1 : count];\n      count++;\n    }\n    while (count < length) {\n      index = fromRight ? length - count - 1 : count;\n      if (index in arr) {\n        result = fn(result, arr[index], index, arr);\n      }\n      count++;\n    }\n    return result;\n  }\n  defineStaticPolyfill(sugarArray, {\n    /***\n     *\n     * @method isArray(obj)\n     * @returns Boolean\n     * @polyfill ES5\n     * @static\n     * @short Returns true if `obj` is an Array.\n     *\n     * @example\n     *\n     *   Array.isArray(3)        -> false\n     *   Array.isArray(true)     -> false\n     *   Array.isArray('wasabi') -> false\n     *   Array.isArray([1,2,3])  -> true\n     *\n     ***/\n    'isArray': function (obj) {\n      return isArray(obj);\n    }\n  });\n  defineInstancePolyfill(sugarArray, {\n    'every': function (fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      var length = this.length,\n        index = 0;\n      assertCallable(fn);\n      while (index < length) {\n        if (index in this && !fn.call(context, this[index], index, this)) {\n          return false;\n        }\n        index++;\n      }\n      return true;\n    },\n    'some': function (fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      var length = this.length,\n        index = 0;\n      assertCallable(fn);\n      while (index < length) {\n        if (index in this && fn.call(context, this[index], index, this)) {\n          return true;\n        }\n        index++;\n      }\n      return false;\n    },\n    'map': function (fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      var length = this.length,\n        index = 0,\n        result = new Array(length);\n      assertCallable(fn);\n      while (index < length) {\n        if (index in this) {\n          result[index] = fn.call(context, this[index], index, this);\n        }\n        index++;\n      }\n      return result;\n    },\n    'filter': function (fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      var length = this.length,\n        index = 0,\n        result = [];\n      assertCallable(fn);\n      while (index < length) {\n        if (index in this && fn.call(context, this[index], index, this)) {\n          result.push(this[index]);\n        }\n        index++;\n      }\n      return result;\n    },\n    /***\n     * @method indexOf(search, [fromIndex] = 0)\n     * @returns Number\n     * @polyfill ES5\n     * @short Searches the array and returns the first index where `search` occurs,\n     *        or `-1` if the element is not found.\n     * @extra [fromIndex] is the index from which to begin the search. This\n     *        method performs a simple strict equality comparison on `search`.\n     *        Sugar does not enhance this method to support `enhanced matching`.\n     *        For such functionality, use the `findIndex` method instead.\n     *\n     * @example\n     *\n     *   [1,2,3].indexOf(3) -> 1\n     *   [1,2,3].indexOf(7) -> -1\n     *\n     ***/\n    'indexOf': function (search) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        fromIndex = arguments[1];\n      if (isString(this)) return this.indexOf(search, fromIndex);\n      return arrayIndexOf(this, search, fromIndex);\n    },\n    /***\n     * @method lastIndexOf(search, [fromIndex] = array.length - 1)\n     * @returns Number\n     * @polyfill ES5\n     * @short Searches the array from the end and returns the first index where\n     *        `search` occurs, or `-1` if the element is not found.\n     * @extra [fromIndex] is the index from which to begin the search. This method\n     *        performs a simple strict equality comparison on `search`.\n     *        Sugar does not enhance this method to support `enhanced matching`.\n     *\n     * @example\n     *\n     *   [1,2,1].lastIndexOf(1) -> 2\n     *   [1,2,1].lastIndexOf(7) -> -1\n     *\n     ***/\n    'lastIndexOf': function (search) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        fromIndex = arguments[1];\n      if (isString(this)) return this.lastIndexOf(search, fromIndex);\n      return arrayIndexOf(this, search, fromIndex, true);\n    },\n    /***\n     * @method forEach([eachFn], [context])\n     * @polyfill ES5\n     * @short Iterates over the array, calling [eachFn] on each loop.\n     * @extra [context] becomes the `this` object.\n     *\n     * @callback eachFn\n     *\n     *   el   The element of the current iteration.\n     *   i    The index of the current iteration.\n     *   arr  A reference to the array.\n     *\n     * @example\n     *\n     *   ['a','b','c'].forEach(function(a) {\n     *     // Called 3 times: 'a','b','c'\n     *   });\n     *\n     ***/\n    'forEach': function (eachFn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      var length = this.length,\n        index = 0;\n      assertCallable(eachFn);\n      while (index < length) {\n        if (index in this) {\n          eachFn.call(context, this[index], index, this);\n        }\n        index++;\n      }\n    },\n    /***\n     * @method reduce(reduceFn, [init])\n     * @returns Mixed\n     * @polyfill ES5\n     * @short Reduces the array to a single result.\n     * @extra This operation is sometimes called \"accumulation\", as it takes the\n     *        result of the last iteration of `reduceFn` and passes it as the first\n     *        argument to the next iteration, \"accumulating\" that value as it goes.\n     *        The return value of this method will be the return value of the final\n     *        iteration of `reduceFn`. If [init] is passed, it will be the initial\n     *        \"accumulator\" (the first argument). If [init] is not passed, then it\n     *        will take the first element in the array, and `reduceFn` will not be\n     *        called for that element.\n     *\n     * @callback reduceFn\n     *\n     *   acc  The \"accumulator\". Either [init], the result of the last iteration\n     *        of `reduceFn`, or the first element of the array.\n     *   el   The current element for this iteration.\n     *   idx  The current index for this iteration.\n     *   arr  A reference to the array.\n     *\n     * @example\n     *\n     *   [1,2,3].reduce(function(a, b) {\n     *     return a - b; // 1 - 2 - 3\n     *   });\n     *\n     *   [1,2,3].reduce(function(a, b) {\n     *     return a - b; // 100 - 1 - 2 - 3\n     *   }, 100);\n     *\n     ***/\n    'reduce': function (reduceFn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      return arrayReduce(this, reduceFn, context);\n    },\n    /***\n     * @method reduceRight([reduceFn], [init])\n     * @returns Mixed\n     * @polyfill ES5\n     * @short Similar to `Array#reduce`, but operates on the elements in reverse.\n     *\n     * @callback reduceFn\n     *\n     *   acc  The \"accumulator\", either [init], the result of the last iteration\n     *        of `reduceFn`, or the last element of the array.\n     *   el   The current element for this iteration.\n     *   idx  The current index for this iteration.\n     *   arr  A reference to the array.\n     *\n     * @example\n     *\n     *   [1,2,3].reduceRight(function(a, b) {\n     *     return a - b; // 3 - 2 - 1\n     *   });\n     *\n     *   [1,2,3].reduceRight(function(a, b) {\n     *     return a - b; // 100 - 3 - 2 - 1\n     *   }, 100);\n     *\n     *\n     ***/\n    'reduceRight': function (reduceFn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length,\n        context = arguments[1];\n      return arrayReduce(this, reduceFn, context, true);\n    }\n  });\n\n  /*** @namespace String ***/\n\n  var TRIM_REG = RegExp('^[' + TRIM_CHARS + ']+|[' + TRIM_CHARS + ']+$', 'g');\n  defineInstancePolyfill(sugarString, {\n    /***\n     * @method trim()\n     * @returns String\n     * @polyfill ES5\n     * @short Removes leading and trailing whitespace from the string.\n     * @extra Whitespace is defined as line breaks, tabs, and any character in the\n     *        \"Space, Separator\" Unicode category, conforming to the the ES5 spec.\n     *\n     * @example\n     *\n     *   '   wasabi   '.trim()      -> 'wasabi'\n     *   '   wasabi   '.trimLeft()  -> 'wasabi   '\n     *   '   wasabi   '.trimRight() -> '   wasabi'\n     *\n     ***/\n    'trim': function () {\n      return this.toString().replace(TRIM_REG, '');\n    }\n  });\n\n  /*** @namespace Function ***/\n\n  defineInstancePolyfill(sugarFunction, {\n    /***\n    * @method bind(context, [arg1], ...)\n    * @returns Function\n    * @polyfill ES5\n    * @short Binds `context` as the `this` object for the function when it is\n    *        called. Also allows currying an unlimited number of parameters.\n    * @extra \"currying\" means setting parameters ([arg1], [arg2], etc.) ahead of\n    *        time so that they are passed when the function is called later. If\n    *        you pass additional parameters when the function is actually called,\n    *        they will be added to the end of the curried parameters.\n    *\n    * @example\n    *\n    *   logThis.bind('woof')()   -> logs 'woof' as its this object\n    *   addArgs.bind(1, 2, 3)()  -> returns 5 with 1 as the this object\n    *   addArgs.bind(1)(2, 3, 4) -> returns 9\n    *\n    ***/\n    'bind': function (context) {\n      // Optimized: no leaking arguments\n      var boundArgs = [];\n      for (var $i = 1, $len = arguments.length; $i < $len; $i++) boundArgs.push(arguments[$i]);\n      var fn = this,\n        bound;\n      assertCallable(this);\n      bound = function () {\n        // Optimized: no leaking arguments\n        var args = [];\n        for (var $i = 0, $len = arguments.length; $i < $len; $i++) args.push(arguments[$i]);\n        return fn.apply(fn.prototype && this instanceof fn ? this : context, boundArgs.concat(args));\n      };\n      bound.prototype = this.prototype;\n      return bound;\n    }\n  });\n\n  /*** @namespace Date ***/\n\n  defineStaticPolyfill(sugarDate, {\n    /***\n    * @method now()\n    * @returns String\n    * @polyfill ES5\n    * @static\n    * @short Returns the current time as a Unix timestamp.\n    * @extra The number of milliseconds since January 1st, 1970 00:00:00 (UTC).\n    *\n    * @example\n    *\n    *   Date.now() -> ex. 1311938296231\n    *\n    ***/\n    'now': function () {\n      return new Date().getTime();\n    }\n  });\n  function hasISOSupport() {\n    var d = new Date(Date.UTC(2000, 0));\n    return !!d.toISOString && d.toISOString() === '2000-01-01T00:00:00.000Z';\n  }\n  defineInstancePolyfill(sugarDate, {\n    /***\n    * @method toISOString()\n    * @returns String\n    * @polyfill ES5\n    * @short Formats the string to ISO8601 format.\n    * @extra This will always format as UTC time.\n    *\n    * @example\n    *\n    *   Date.create().toISOString() -> ex. 2011-07-05 12:24:55.528Z\n    *\n    ***/\n    'toISOString': function () {\n      return padNumber(this.getUTCFullYear(), 4) + '-' + padNumber(this.getUTCMonth() + 1, 2) + '-' + padNumber(this.getUTCDate(), 2) + 'T' + padNumber(this.getUTCHours(), 2) + ':' + padNumber(this.getUTCMinutes(), 2) + ':' + padNumber(this.getUTCSeconds(), 2) + '.' + padNumber(this.getUTCMilliseconds(), 3) + 'Z';\n    },\n    /***\n    * @method toJSON([key])\n    * @returns String\n    * @polyfill ES5\n    * @short Returns a JSON representation of the date.\n    * @extra This is effectively an alias for `toISOString`. Will always return\n    *        the date in UTC time. [key] is ignored.\n    *\n    * @example\n    *\n    *   Date.create().toJSON() -> ex. 2011-07-05 12:24:55.528Z\n    *\n    ***/\n    'toJSON': function (key) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length;\n      return this.toISOString(key);\n    }\n  }, !hasISOSupport());\n}).call(this);","map":{"version":3,"names":["Sugar","SUGAR_GLOBAL","NATIVE_NAMES","STATIC","INSTANCE","PROPERTY_DESCRIPTOR_SUPPORT","Object","defineProperty","defineProperties","globalContext","getGlobal","allowObjectPrototype","namespacesByName","namespacesByClassString","definePropertyShim","DefaultChainable","getNewChainableClass","testGlobal","global","window","obj","setupGlobal","arg","forEachProperty","sugarNamespace","name","hasOwn","extend","module","exports","e","split","createNamespace","setGlobalProperties","isObject","opts","nativeClass","nativeProto","prototype","staticMethods","instanceMethods","methodsByName","objectRestricted","target","arrayOptionExists","field","val","arr","i","el","arrayOptionExcludes","disallowedByFlags","methodName","flags","length","namespaceIsExcepted","methodIsExcepted","canExtend","method","methods","objectPrototype","instance","extendNative","setProperty","defineWithOptionCollect","args","arg1","arg2","arg3","collectDefineOptions","defineMethods","last","fn","defineChainableMethod","source","setMethod","mapNativeToChainable","mapObjectChainablesToNamespace","toString","getOwn","classToString","type","instanceMethod","staticMethod","wrapMethodWithArguments","wrapInstanceMethod","active","wrapInstanceMethodFixed","startCollect","collectedArgs","len","push","Math","max","arguments","apply","a","b","c","d","polyfill","override","SugarChainable","constructor","raw","wrapped","wrapWithChainableResult","existing","collision","dcp","disambiguate","disambiguateMethod","mapObjectChainableToAllNamespaces","setObjectChainableOnNamespace","proto","methodNames","ownPropertyNames","nativeMethodProhibited","getOwnPropertyNames","internalToString","internalHasOwnProperty","hasOwnProperty","key","call","prop","descriptor","value","enumerable","configurable","writable","ENHANCEMENTS_FLAG","NATIVE_TYPES","NO_KEYS_IN_STRING_OBJECTS","PRIVATE_PROP_PREFIX","PROPERTY_RANGE_REG","TRIM_CHARS","STRING_FORMAT_REG","HALF_WIDTH_ZERO","FULL_WIDTH_ZERO","HALF_WIDTH_PERIOD","FULL_WIDTH_PERIOD","HALF_WIDTH_COMMA","OPEN_BRACE","CLOSE_BRACE","sugarObject","sugarArray","Array","sugarDate","Date","sugarString","String","sugarNumber","Number","sugarFunction","Function","sugarRegExp","RegExp","isSerializable","isBoolean","isNumber","isString","isDate","isRegExp","isFunction","isArray","isSet","isMap","isError","buildClassChecks","knownTypes","addCoreTypes","names","spaceSplit","buildPrimitiveClassCheck","buildClassCheck","Set","Map","addKnownType","addArrayTypes","types","forEach","str","className","isKnownType","globalObject","isClass","getConstructorClassCheck","getToStringClassCheck","ctorStr","toLowerCase","t","isPlainObject","wrapNamespace","alias","defineStatic","defineInstance","defineStaticPolyfill","defineInstancePolyfill","defineInstanceAndStatic","defineInstanceWithArguments","defineInstanceSimilar","set","collectSimilarMethods","defineInstanceAndStaticSimilar","fixArgumentLength","staticFn","defineAccessor","namespace","defineOptionsAccessor","defaults","simpleClone","getOption","setOption","options","defineOnPrototype","ctor","assertArgument","exists","TypeError","assertCallable","assertArray","assertWritable","isPrimitive","coercePositiveInteger","n","isFinite","RangeError","trunc","isDefined","o","undefined","isUndefined","privatePropertyAccessor","privateKey","setChainableConstructor","createFn","getMatcher","f","regexMatcher","dateMatcher","functionMatcher","fuzzyMatcher","defaultMatcher","matchers","matched","isObjectType","isEqual","reg","test","ms","getTime","getKeys","keys","deepHasProperty","any","handleDeepProperty","deepGetProperty","deepSetProperty","has","fill","fillLast","ns","bs","ps","cbi","isLast","isPush","isIndex","nextIsIndex","indexOf","handleArrayIndexRange","blen","periodSplit","j","plen","slice","match","start","end","leading","trailing","charAt","map","getOwnKey","hasProperty","hasValidPlainObjectPrototype","hasOwnEnumeratedProperties","hasToString","hasConstructor","objectProto","simpleRepeat","simpleMerge","coercePrimitiveToObject","forceStringCoercion","chr","stack","aClass","bClass","objectIsEqual","size","setToArray","mapToArray","aType","bType","propsEqual","count","valueOf","iterateWithCyclicCheck","cyc","serializeInternal","refs","sign","ref","Infinity","isRealNaN","serializeDeep","result","sortedKeys","next","pop","iterateWithSortedKeys","sort","isArrayIndex","iterateOverSparseArray","fromIndex","loop","indexes","getSparseArrayIndexes","index","fromRight","aLoop","bLoop","getEntriesForIndexes","find","entryAtIndex","getNormalizedIndex","mapWithShortcuts","context","mapArgs","m","commaSplit","filter","ceil","floor","withPrecision","precision","multiplier","pow","abs","round","padNumber","num","place","base","replacement","repeatString","replace","getOrdinalSuffix","fullWidthNumberReg","fullWidthNumberMap","fullWidthNumbers","buildFullWidthNumber","fwp","hwp","hwc","fwn","digit","allCharsReg","stringToNumber","sanitized","isDecimal","parseFloat","parseInt","min","fromCharCode","trim","simpleCapitalize","toUpperCase","createFormatMatcher","bracketMatcher","percentMatcher","precheck","compileMemoized","memoizeFunction","compile","getToken","format","get","token","literal","bKey","pLit","pKey","assertPassesPrecheck","opt","getLiteral","getSubstring","sub","assertNoUnmatched","bt","pt","lastIndex","exec","Inflections","getAcronym","acronyms","getHumanWord","human","runHumanRules","runRules","src","getRegExpFlags","add","checkFlag","flag","ignoreCase","multiline","sticky","escapeRegExp","_utc","callDateGet","callDateSet","safe","INTERNAL_MEMOIZE_LIMIT","memo","counter","DONT_ENUM_PROPS","buildDontEnumFix","propertyIsEnumerable","forEachEnumerableProperty","buildChainableNativeMethodsFix","defineNativeMethodsOnChainable","nativeTokens","dateTokens","addDateTokens","prefix","tokens","assertNonNull","arrayIndexOf","search","defaultFromIndex","increment","sparseIndexOf","shift","arrayReduce","initialValue","defined","every","argLen","some","lastIndexOf","eachFn","reduce","reduceFn","reduceRight","TRIM_REG","bind","boundArgs","$i","$len","bound","concat","now","hasISOSupport","UTC","toISOString","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","toJSON"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/todo/node_modules/sugar-core/sugar-core.js"],"sourcesContent":["/*\n *  Sugar v2.0.6\n *\n *  Freely distributable and licensed under the MIT-style license.\n *  Copyright (c) Andrew Plummer\n *  https://sugarjs.com/\n *\n * ---------------------------- */\n(function() {\n  'use strict';\n\n  /***\n   * @module Core\n   * @description Core functionality including the ability to define methods and\n   *              extend onto natives.\n   *\n   ***/\n\n  // The global to export.\n  var Sugar;\n\n  // The name of Sugar in the global namespace.\n  var SUGAR_GLOBAL = 'Sugar';\n\n  // Natives available on initialization. Letting Object go first to ensure its\n  // global is set by the time the rest are checking for chainable Object methods.\n  var NATIVE_NAMES = 'Object Number String Array Date RegExp Function';\n\n  // Static method flag\n  var STATIC   = 0x1;\n\n  // Instance method flag\n  var INSTANCE = 0x2;\n\n  // IE8 has a broken defineProperty but no defineProperties so this saves a try/catch.\n  var PROPERTY_DESCRIPTOR_SUPPORT = !!(Object.defineProperty && Object.defineProperties);\n\n  var globalContext = getGlobal();\n\n  // Whether object instance methods can be mapped to the prototype.\n  var allowObjectPrototype = false;\n\n  // A map from Array to SugarArray.\n  var namespacesByName = {};\n\n  // A map from [object Object] to namespace.\n  var namespacesByClassString = {};\n\n  // Defining properties.\n  // istanbul ignore next\n  var defineProperty = PROPERTY_DESCRIPTOR_SUPPORT ?  Object.defineProperty : definePropertyShim;\n\n  // A default chainable class for unknown types.\n  var DefaultChainable = getNewChainableClass('Chainable');\n\n\n  // Global methods\n\n  function getGlobal() {\n    // Get global context by keyword here to avoid issues with libraries\n    // that can potentially alter this script's context object.\n    return testGlobal(typeof global !== 'undefined' && global) ||\n           testGlobal(typeof window !== 'undefined' && window);\n  }\n\n  function testGlobal(obj) {\n    // Note that Rhino uses a different \"global\" keyword so perform an\n    // extra check here to ensure that it's actually the global object.\n    return obj && obj.Object === Object ? obj : null;\n  }\n\n  function setupGlobal() {\n    Sugar = globalContext[SUGAR_GLOBAL];\n    // istanbul ignore if\n    if (Sugar) {\n      // Reuse already defined Sugar global object.\n      return;\n    }\n    Sugar = function(arg) {\n      forEachProperty(Sugar, function(sugarNamespace, name) {\n        // Although only the only enumerable properties on the global\n        // object are Sugar namespaces, environments that can't set\n        // non-enumerable properties will step through the utility methods\n        // as well here, so use this check to only allow true namespaces.\n        if (hasOwn(namespacesByName, name)) {\n          sugarNamespace.extend(arg);\n        }\n      });\n      return Sugar;\n    };\n    // istanbul ignore else\n    if (typeof module !== 'undefined' && module.exports) {\n      // Node or webpack environment\n      module.exports = Sugar;\n    } else {\n      // Unwrapped browser environment\n      try {\n        globalContext[SUGAR_GLOBAL] = Sugar;\n      } catch (e) {\n        // Contexts such as QML have a read-only global context.\n      }\n    }\n    forEachProperty(NATIVE_NAMES.split(' '), function(name) {\n      createNamespace(name);\n    });\n    setGlobalProperties();\n  }\n\n  /***\n   * @method createNamespace(name)\n   * @returns SugarNamespace\n   * @namespace Sugar\n   * @short Creates a new Sugar namespace.\n   * @extra This method is for plugin developers who want to define methods to be\n   *        used with natives that Sugar does not handle by default. The new\n   *        namespace will appear on the `Sugar` global with all the methods of\n   *        normal namespaces, including the ability to define new methods. When\n   *        extended, any defined methods will be mapped to `name` in the global\n   *        context.\n   *\n   * @example\n   *\n   *   Sugar.createNamespace('Boolean');\n   *\n   * @param {string} name - The namespace name.\n   *\n   ***/\n  function createNamespace(name) {\n\n    // Is the current namespace Object?\n    var isObject = name === 'Object';\n\n    // A Sugar namespace is also a chainable class: Sugar.Array, etc.\n    var sugarNamespace = getNewChainableClass(name, true);\n\n    /***\n     * @method extend([opts])\n     * @returns Sugar\n     * @namespace Sugar\n     * @short Extends Sugar defined methods onto natives.\n     * @extra This method can be called on individual namespaces like\n     *        `Sugar.Array` or on the `Sugar` global itself, in which case\n     *        [opts] will be forwarded to each `extend` call. For more,\n     *        see `extending`.\n     *\n     * @options\n     *\n     *   methods           An array of method names to explicitly extend.\n     *\n     *   except            An array of method names or global namespaces (`Array`,\n     *                     `String`) to explicitly exclude. Namespaces should be the\n     *                     actual global objects, not strings.\n     *\n     *   namespaces        An array of global namespaces (`Array`, `String`) to\n     *                     explicitly extend. Namespaces should be the actual\n     *                     global objects, not strings.\n     *\n     *   enhance           A shortcut to disallow all \"enhance\" flags at once\n     *                     (flags listed below). For more, see `enhanced methods`.\n     *                     Default is `true`.\n     *\n     *   enhanceString     A boolean allowing String enhancements. Default is `true`.\n     *\n     *   enhanceArray      A boolean allowing Array enhancements. Default is `true`.\n     *\n     *   objectPrototype   A boolean allowing Sugar to extend Object.prototype\n     *                     with instance methods. This option is off by default\n     *                     and should generally not be used except with caution.\n     *                     For more, see `object methods`.\n     *\n     * @example\n     *\n     *   Sugar.Array.extend();\n     *   Sugar.extend();\n     *\n     * @option {Array<string>} [methods]\n     * @option {Array<string|NativeConstructor>} [except]\n     * @option {Array<NativeConstructor>} [namespaces]\n     * @option {boolean} [enhance]\n     * @option {boolean} [enhanceString]\n     * @option {boolean} [enhanceArray]\n     * @option {boolean} [objectPrototype]\n     * @param {ExtendOptions} [opts]\n     *\n     ***\n     * @method extend([opts])\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Extends Sugar defined methods for a specific namespace onto natives.\n     * @param {ExtendOptions} [opts]\n     *\n     ***/\n    var extend = function (opts) {\n\n      var nativeClass = globalContext[name], nativeProto = nativeClass.prototype;\n      var staticMethods = {}, instanceMethods = {}, methodsByName;\n\n      function objectRestricted(name, target) {\n        return isObject && target === nativeProto &&\n               (!allowObjectPrototype || name === 'get' || name === 'set');\n      }\n\n      function arrayOptionExists(field, val) {\n        var arr = opts[field];\n        if (arr) {\n          for (var i = 0, el; el = arr[i]; i++) {\n            if (el === val) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n\n      function arrayOptionExcludes(field, val) {\n        return opts[field] && !arrayOptionExists(field, val);\n      }\n\n      function disallowedByFlags(methodName, target, flags) {\n        // Disallowing methods by flag currently only applies if methods already\n        // exist to avoid enhancing native methods, as aliases should still be\n        // extended (i.e. Array#all should still be extended even if Array#every\n        // is being disallowed by a flag).\n        if (!target[methodName] || !flags) {\n          return false;\n        }\n        for (var i = 0; i < flags.length; i++) {\n          if (opts[flags[i]] === false) {\n            return true;\n          }\n        }\n      }\n\n      function namespaceIsExcepted() {\n        return arrayOptionExists('except', nativeClass) ||\n               arrayOptionExcludes('namespaces', nativeClass);\n      }\n\n      function methodIsExcepted(methodName) {\n        return arrayOptionExists('except', methodName);\n      }\n\n      function canExtend(methodName, method, target) {\n        return !objectRestricted(methodName, target) &&\n               !disallowedByFlags(methodName, target, method.flags) &&\n               !methodIsExcepted(methodName);\n      }\n\n      opts = opts || {};\n      methodsByName = opts.methods;\n\n      if (namespaceIsExcepted()) {\n        return;\n      } else if (isObject && typeof opts.objectPrototype === 'boolean') {\n        // Store \"objectPrototype\" flag for future reference.\n        allowObjectPrototype = opts.objectPrototype;\n      }\n\n      forEachProperty(methodsByName || sugarNamespace, function(method, methodName) {\n        if (methodsByName) {\n          // If we have method names passed in an array,\n          // then we need to flip the key and value here\n          // and find the method in the Sugar namespace.\n          methodName = method;\n          method = sugarNamespace[methodName];\n        }\n        if (hasOwn(method, 'instance') && canExtend(methodName, method, nativeProto)) {\n          instanceMethods[methodName] = method.instance;\n        }\n        if(hasOwn(method, 'static') && canExtend(methodName, method, nativeClass)) {\n          staticMethods[methodName] = method;\n        }\n      });\n\n      // Accessing the extend target each time instead of holding a reference as\n      // it may have been overwritten (for example Date by Sinon). Also need to\n      // access through the global to allow extension of user-defined namespaces.\n      extendNative(nativeClass, staticMethods);\n      extendNative(nativeProto, instanceMethods);\n\n      if (!methodsByName) {\n        // If there are no method names passed, then\n        // all methods in the namespace will be extended\n        // to the native. This includes all future defined\n        // methods, so add a flag here to check later.\n        setProperty(sugarNamespace, 'active', true);\n      }\n      return sugarNamespace;\n    };\n\n    function defineWithOptionCollect(methodName, instance, args) {\n      setProperty(sugarNamespace, methodName, function(arg1, arg2, arg3) {\n        var opts = collectDefineOptions(arg1, arg2, arg3);\n        defineMethods(sugarNamespace, opts.methods, instance, args, opts.last);\n        return sugarNamespace;\n      });\n    }\n\n    /***\n     * @method defineStatic(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines static methods on the namespace that can later be extended\n     *        onto the native globals.\n     * @extra Accepts either a single object mapping names to functions, or name\n     *        and function as two arguments. If `extend` was previously called\n     *        with no arguments, the method will be immediately mapped to its\n     *        native when defined.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineStatic({\n     *     isOdd: function (num) {\n     *       return num % 2 === 1;\n     *     }\n     *   });\n     *\n     * @signature defineStatic(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineStatic', STATIC);\n\n    /***\n     * @method defineInstance(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines methods on the namespace that can later be extended as\n     *        instance methods onto the native prototype.\n     * @extra Accepts either a single object mapping names to functions, or name\n     *        and function as two arguments. All functions should accept the\n     *        native for which they are mapped as their first argument, and should\n     *        never refer to `this`. If `extend` was previously called with no\n     *        arguments, the method will be immediately mapped to its native when\n     *        defined.\n     *\n     *        Methods cannot accept more than 4 arguments in addition to the\n     *        native (5 arguments total). Any additional arguments will not be\n     *        mapped. If the method needs to accept unlimited arguments, use\n     *        `defineInstanceWithArguments`. Otherwise if more options are\n     *        required, use an options object instead.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineInstance({\n     *     square: function (num) {\n     *       return num * num;\n     *     }\n     *   });\n     *\n     * @signature defineInstance(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineInstance', INSTANCE);\n\n    /***\n     * @method defineInstanceAndStatic(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short A shortcut to define both static and instance methods on the namespace.\n     * @extra This method is intended for use with `Object` instance methods. Sugar\n     *        will not map any methods to `Object.prototype` by default, so defining\n     *        instance methods as static helps facilitate their proper use.\n     *\n     * @example\n     *\n     *   Sugar.Object.defineInstanceAndStatic({\n     *     isAwesome: function (obj) {\n     *       // check if obj is awesome!\n     *     }\n     *   });\n     *\n     * @signature defineInstanceAndStatic(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineInstanceAndStatic', INSTANCE | STATIC);\n\n\n    /***\n     * @method defineStaticWithArguments(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines static methods that collect arguments.\n     * @extra This method is identical to `defineStatic`, except that when defined\n     *        methods are called, they will collect any arguments past `n - 1`,\n     *        where `n` is the number of arguments that the method accepts.\n     *        Collected arguments will be passed to the method in an array\n     *        as the last argument defined on the function.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineStaticWithArguments({\n     *     addAll: function (num, args) {\n     *       for (var i = 0; i < args.length; i++) {\n     *         num += args[i];\n     *       }\n     *       return num;\n     *     }\n     *   });\n     *\n     * @signature defineStaticWithArguments(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineStaticWithArguments', STATIC, true);\n\n    /***\n     * @method defineInstanceWithArguments(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines instance methods that collect arguments.\n     * @extra This method is identical to `defineInstance`, except that when\n     *        defined methods are called, they will collect any arguments past\n     *        `n - 1`, where `n` is the number of arguments that the method\n     *        accepts. Collected arguments will be passed to the method as the\n     *        last argument defined on the function.\n     *\n     * @example\n     *\n     *   Sugar.Number.defineInstanceWithArguments({\n     *     addAll: function (num, args) {\n     *       for (var i = 0; i < args.length; i++) {\n     *         num += args[i];\n     *       }\n     *       return num;\n     *     }\n     *   });\n     *\n     * @signature defineInstanceWithArguments(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    defineWithOptionCollect('defineInstanceWithArguments', INSTANCE, true);\n\n    /***\n     * @method defineStaticPolyfill(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines static methods that are mapped onto the native if they do\n     *        not already exist.\n     * @extra Intended only for use creating polyfills that follow the ECMAScript\n     *        spec. Accepts either a single object mapping names to functions, or\n     *        name and function as two arguments. Note that polyfill methods will\n     *        be immediately mapped onto their native prototype regardless of the\n     *        use of `extend`.\n     *\n     * @example\n     *\n     *   Sugar.Object.defineStaticPolyfill({\n     *     keys: function (obj) {\n     *       // get keys!\n     *     }\n     *   });\n     *\n     * @signature defineStaticPolyfill(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    setProperty(sugarNamespace, 'defineStaticPolyfill', function(arg1, arg2, arg3) {\n      var opts = collectDefineOptions(arg1, arg2, arg3);\n      extendNative(globalContext[name], opts.methods, true, opts.last);\n      return sugarNamespace;\n    });\n\n    /***\n     * @method defineInstancePolyfill(methods)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Defines instance methods that are mapped onto the native prototype\n     *        if they do not already exist.\n     * @extra Intended only for use creating polyfills that follow the ECMAScript\n     *        spec. Accepts either a single object mapping names to functions, or\n     *        name and function as two arguments. This method differs from\n     *        `defineInstance` as there is no static signature (as the method\n     *        is mapped as-is to the native), so it should refer to its `this`\n     *        object. Note that polyfill methods will be immediately mapped onto\n     *        their native prototype regardless of the use of `extend`.\n     *\n     * @example\n     *\n     *   Sugar.Array.defineInstancePolyfill({\n     *     indexOf: function (arr, el) {\n     *       // index finding code here!\n     *     }\n     *   });\n     *\n     * @signature defineInstancePolyfill(methodName, methodFn)\n     * @param {Object} methods - Methods to be defined.\n     * @param {string} methodName - Name of a single method to be defined.\n     * @param {Function} methodFn - Function body of a single method to be defined.\n     ***/\n    setProperty(sugarNamespace, 'defineInstancePolyfill', function(arg1, arg2, arg3) {\n      var opts = collectDefineOptions(arg1, arg2, arg3);\n      extendNative(globalContext[name].prototype, opts.methods, true, opts.last);\n      // Map instance polyfills to chainable as well.\n      forEachProperty(opts.methods, function(fn, methodName) {\n        defineChainableMethod(sugarNamespace, methodName, fn);\n      });\n      return sugarNamespace;\n    });\n\n    /***\n     * @method alias(toName, from)\n     * @returns SugarNamespace\n     * @namespace SugarNamespace\n     * @short Aliases one Sugar method to another.\n     *\n     * @example\n     *\n     *   Sugar.Array.alias('all', 'every');\n     *\n     * @signature alias(toName, fn)\n     * @param {string} toName - Name for new method.\n     * @param {string|Function} from - Method to alias, or string shortcut.\n     ***/\n    setProperty(sugarNamespace, 'alias', function(name, source) {\n      var method = typeof source === 'string' ? sugarNamespace[source] : source;\n      setMethod(sugarNamespace, name, method);\n      return sugarNamespace;\n    });\n\n    // Each namespace can extend only itself through its .extend method.\n    setProperty(sugarNamespace, 'extend', extend);\n\n    // Cache the class to namespace relationship for later use.\n    namespacesByName[name] = sugarNamespace;\n    namespacesByClassString['[object ' + name + ']'] = sugarNamespace;\n\n    mapNativeToChainable(name);\n    mapObjectChainablesToNamespace(sugarNamespace);\n\n\n    // Export\n    return Sugar[name] = sugarNamespace;\n  }\n\n  function setGlobalProperties() {\n    setProperty(Sugar, 'VERSION', '2.0.6');\n    setProperty(Sugar, 'extend', Sugar);\n    setProperty(Sugar, 'toString', toString);\n    setProperty(Sugar, 'createNamespace', createNamespace);\n\n    setProperty(Sugar, 'util', {\n      'hasOwn': hasOwn,\n      'getOwn': getOwn,\n      'setProperty': setProperty,\n      'classToString': classToString,\n      'defineProperty': defineProperty,\n      'forEachProperty': forEachProperty,\n      'mapNativeToChainable': mapNativeToChainable\n    });\n  }\n\n  function toString() {\n    return SUGAR_GLOBAL;\n  }\n\n\n  // Defining Methods\n\n  function defineMethods(sugarNamespace, methods, type, args, flags) {\n    forEachProperty(methods, function(method, methodName) {\n      var instanceMethod, staticMethod = method;\n      if (args) {\n        staticMethod = wrapMethodWithArguments(method);\n      }\n      if (flags) {\n        staticMethod.flags = flags;\n      }\n\n      // A method may define its own custom implementation, so\n      // make sure that's not the case before creating one.\n      if (type & INSTANCE && !method.instance) {\n        instanceMethod = wrapInstanceMethod(method, args);\n        setProperty(staticMethod, 'instance', instanceMethod);\n      }\n\n      if (type & STATIC) {\n        setProperty(staticMethod, 'static', true);\n      }\n\n      setMethod(sugarNamespace, methodName, staticMethod);\n\n      if (sugarNamespace.active) {\n        // If the namespace has been activated (.extend has been called),\n        // then map this method as well.\n        sugarNamespace.extend(methodName);\n      }\n    });\n  }\n\n  function collectDefineOptions(arg1, arg2, arg3) {\n    var methods, last;\n    if (typeof arg1 === 'string') {\n      methods = {};\n      methods[arg1] = arg2;\n      last = arg3;\n    } else {\n      methods = arg1;\n      last = arg2;\n    }\n    return {\n      last: last,\n      methods: methods\n    };\n  }\n\n  function wrapInstanceMethod(fn, args) {\n    return args ? wrapMethodWithArguments(fn, true) : wrapInstanceMethodFixed(fn);\n  }\n\n  function wrapMethodWithArguments(fn, instance) {\n    // Functions accepting enumerated arguments will always have \"args\" as the\n    // last argument, so subtract one from the function length to get the point\n    // at which to start collecting arguments. If this is an instance method on\n    // a prototype, then \"this\" will be pushed into the arguments array so start\n    // collecting 1 argument earlier.\n    var startCollect = fn.length - 1 - (instance ? 1 : 0);\n    return function() {\n      var args = [], collectedArgs = [], len;\n      if (instance) {\n        args.push(this);\n      }\n      len = Math.max(arguments.length, startCollect);\n      // Optimized: no leaking arguments\n      for (var i = 0; i < len; i++) {\n        if (i < startCollect) {\n          args.push(arguments[i]);\n        } else {\n          collectedArgs.push(arguments[i]);\n        }\n      }\n      args.push(collectedArgs);\n      return fn.apply(this, args);\n    };\n  }\n\n  function wrapInstanceMethodFixed(fn) {\n    switch(fn.length) {\n      // Wrapped instance methods will always be passed the instance\n      // as the first argument, but requiring the argument to be defined\n      // may cause confusion here, so return the same wrapped function regardless.\n      case 0:\n      case 1:\n        return function() {\n          return fn(this);\n        };\n      case 2:\n        return function(a) {\n          return fn(this, a);\n        };\n      case 3:\n        return function(a, b) {\n          return fn(this, a, b);\n        };\n      case 4:\n        return function(a, b, c) {\n          return fn(this, a, b, c);\n        };\n      case 5:\n        return function(a, b, c, d) {\n          return fn(this, a, b, c, d);\n        };\n    }\n  }\n\n  // Method helpers\n\n  function extendNative(target, source, polyfill, override) {\n    forEachProperty(source, function(method, name) {\n      if (polyfill && !override && target[name]) {\n        // Method exists, so bail.\n        return;\n      }\n      setProperty(target, name, method);\n    });\n  }\n\n  function setMethod(sugarNamespace, methodName, method) {\n    sugarNamespace[methodName] = method;\n    if (method.instance) {\n      defineChainableMethod(sugarNamespace, methodName, method.instance, true);\n    }\n  }\n\n\n  // Chainables\n\n  function getNewChainableClass(name) {\n    var fn = function SugarChainable(obj, arg) {\n      if (!(this instanceof fn)) {\n        return new fn(obj, arg);\n      }\n      if (this.constructor !== fn) {\n        // Allow modules to define their own constructors.\n        obj = this.constructor.apply(obj, arguments);\n      }\n      this.raw = obj;\n    };\n    setProperty(fn, 'toString', function() {\n      return SUGAR_GLOBAL + name;\n    });\n    setProperty(fn.prototype, 'valueOf', function() {\n      return this.raw;\n    });\n    return fn;\n  }\n\n  function defineChainableMethod(sugarNamespace, methodName, fn) {\n    var wrapped = wrapWithChainableResult(fn), existing, collision, dcp;\n    dcp = DefaultChainable.prototype;\n    existing = dcp[methodName];\n\n    // If the method was previously defined on the default chainable, then a\n    // collision exists, so set the method to a disambiguation function that will\n    // lazily evaluate the object and find it's associated chainable. An extra\n    // check is required to avoid false positives from Object inherited methods.\n    collision = existing && existing !== Object.prototype[methodName];\n\n    // The disambiguation function is only required once.\n    if (!existing || !existing.disambiguate) {\n      dcp[methodName] = collision ? disambiguateMethod(methodName) : wrapped;\n    }\n\n    // The target chainable always receives the wrapped method. Additionally,\n    // if the target chainable is Sugar.Object, then map the wrapped method\n    // to all other namespaces as well if they do not define their own method\n    // of the same name. This way, a Sugar.Number will have methods like\n    // isEqual that can be called on any object without having to traverse up\n    // the prototype chain and perform disambiguation, which costs cycles.\n    // Note that the \"if\" block below actually does nothing on init as Object\n    // goes first and no other namespaces exist yet. However it needs to be\n    // here as Object instance methods defined later also need to be mapped\n    // back onto existing namespaces.\n    sugarNamespace.prototype[methodName] = wrapped;\n    if (sugarNamespace === Sugar.Object) {\n      mapObjectChainableToAllNamespaces(methodName, wrapped);\n    }\n  }\n\n  function mapObjectChainablesToNamespace(sugarNamespace) {\n    forEachProperty(Sugar.Object && Sugar.Object.prototype, function(val, methodName) {\n      if (typeof val === 'function') {\n        setObjectChainableOnNamespace(sugarNamespace, methodName, val);\n      }\n    });\n  }\n\n  function mapObjectChainableToAllNamespaces(methodName, fn) {\n    forEachProperty(namespacesByName, function(sugarNamespace) {\n      setObjectChainableOnNamespace(sugarNamespace, methodName, fn);\n    });\n  }\n\n  function setObjectChainableOnNamespace(sugarNamespace, methodName, fn) {\n    var proto = sugarNamespace.prototype;\n    if (!hasOwn(proto, methodName)) {\n      proto[methodName] = fn;\n    }\n  }\n\n  function wrapWithChainableResult(fn) {\n    return function() {\n      return new DefaultChainable(fn.apply(this.raw, arguments));\n    };\n  }\n\n  function disambiguateMethod(methodName) {\n    var fn = function() {\n      var raw = this.raw, sugarNamespace;\n      if (raw != null) {\n        // Find the Sugar namespace for this unknown.\n        sugarNamespace = namespacesByClassString[classToString(raw)];\n      }\n      if (!sugarNamespace) {\n        // If no sugarNamespace can be resolved, then default\n        // back to Sugar.Object so that undefined and other\n        // non-supported types can still have basic object\n        // methods called on them, such as type checks.\n        sugarNamespace = Sugar.Object;\n      }\n\n      return new sugarNamespace(raw)[methodName].apply(this, arguments);\n    };\n    fn.disambiguate = true;\n    return fn;\n  }\n\n  function mapNativeToChainable(name, methodNames) {\n    var sugarNamespace = namespacesByName[name],\n        nativeProto = globalContext[name].prototype;\n\n    if (!methodNames && ownPropertyNames) {\n      methodNames = ownPropertyNames(nativeProto);\n    }\n\n    forEachProperty(methodNames, function(methodName) {\n      if (nativeMethodProhibited(methodName)) {\n        // Sugar chainables have their own constructors as well as \"valueOf\"\n        // methods, so exclude them here. The __proto__ argument should be trapped\n        // by the function check below, however simply accessing this property on\n        // Object.prototype causes QML to segfault, so pre-emptively excluding it.\n        return;\n      }\n      try {\n        var fn = nativeProto[methodName];\n        if (typeof fn !== 'function') {\n          // Bail on anything not a function.\n          return;\n        }\n      } catch (e) {\n        // Function.prototype has properties that\n        // will throw errors when accessed.\n        return;\n      }\n      defineChainableMethod(sugarNamespace, methodName, fn);\n    });\n  }\n\n  function nativeMethodProhibited(methodName) {\n    return methodName === 'constructor' ||\n           methodName === 'valueOf' ||\n           methodName === '__proto__';\n  }\n\n\n  // Util\n\n  // Internal references\n  var ownPropertyNames = Object.getOwnPropertyNames,\n      internalToString = Object.prototype.toString,\n      internalHasOwnProperty = Object.prototype.hasOwnProperty;\n\n  // Defining this as a variable here as the ES5 module\n  // overwrites it to patch DONTENUM.\n  var forEachProperty = function (obj, fn) {\n    for(var key in obj) {\n      if (!hasOwn(obj, key)) continue;\n      if (fn.call(obj, obj[key], key, obj) === false) break;\n    }\n  };\n\n  // istanbul ignore next\n  function definePropertyShim(obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n  }\n\n  function setProperty(target, name, value, enumerable) {\n    defineProperty(target, name, {\n      value: value,\n      enumerable: !!enumerable,\n      configurable: true,\n      writable: true\n    });\n  }\n\n  // PERF: Attempts to speed this method up get very Heisenbergy. Quickly\n  // returning based on typeof works for primitives, but slows down object\n  // types. Even === checks on null and undefined (no typeof) will end up\n  // basically breaking even. This seems to be as fast as it can go.\n  function classToString(obj) {\n    return internalToString.call(obj);\n  }\n\n  function hasOwn(obj, prop) {\n    return !!obj && internalHasOwnProperty.call(obj, prop);\n  }\n\n  function getOwn(obj, prop) {\n    if (hasOwn(obj, prop)) {\n      return obj[prop];\n    }\n  }\n\n  setupGlobal();\n\n  /***\n   * @module Common\n   * @description Internal utility and common methods.\n   ***/\n\n  // Flag allowing native methods to be enhanced.\n  var ENHANCEMENTS_FLAG = 'enhance';\n\n  // For type checking, etc. Excludes object as this is more nuanced.\n  var NATIVE_TYPES = 'Boolean Number String Date RegExp Function Array Error Set Map';\n\n  // Do strings have no keys?\n  var NO_KEYS_IN_STRING_OBJECTS = !('0' in Object('a'));\n\n  // Prefix for private properties.\n  var PRIVATE_PROP_PREFIX = '_sugar_';\n\n  // Matches 1..2 style ranges in properties.\n  var PROPERTY_RANGE_REG = /^(.*?)\\[([-\\d]*)\\.\\.([-\\d]*)\\](.*)$/;\n\n  // WhiteSpace/LineTerminator as defined in ES5.1 plus Unicode characters in the Space, Separator category.\n  var TRIM_CHARS = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF';\n\n  // Regex for matching a formatted string.\n  var STRING_FORMAT_REG = /([{}])\\1|{([^}]*)}|(%)%|(%(\\w*))/g;\n\n  // Common chars\n  var HALF_WIDTH_ZERO = 0x30,\n      FULL_WIDTH_ZERO = 0xff10,\n      HALF_WIDTH_PERIOD   = '.',\n      FULL_WIDTH_PERIOD   = '．',\n      HALF_WIDTH_COMMA    = ',',\n      OPEN_BRACE  = '{',\n      CLOSE_BRACE = '}';\n\n  // Namespace aliases\n  var sugarObject   = Sugar.Object,\n      sugarArray    = Sugar.Array,\n      sugarDate     = Sugar.Date,\n      sugarString   = Sugar.String,\n      sugarNumber   = Sugar.Number,\n      sugarFunction = Sugar.Function,\n      sugarRegExp   = Sugar.RegExp;\n\n  // Class checks\n  var isSerializable,\n      isBoolean, isNumber, isString,\n      isDate, isRegExp, isFunction,\n      isArray, isSet, isMap, isError;\n\n  function buildClassChecks() {\n\n    var knownTypes = {};\n\n    function addCoreTypes() {\n\n      var names = spaceSplit(NATIVE_TYPES);\n\n      isBoolean = buildPrimitiveClassCheck(names[0]);\n      isNumber  = buildPrimitiveClassCheck(names[1]);\n      isString  = buildPrimitiveClassCheck(names[2]);\n\n      isDate   = buildClassCheck(names[3]);\n      isRegExp = buildClassCheck(names[4]);\n\n      // Wanted to enhance performance here by using simply \"typeof\"\n      // but Firefox has two major issues that make this impossible,\n      // one fixed, the other not, so perform a full class check here.\n      //\n      // 1. Regexes can be typeof \"function\" in FF < 3\n      //    https://bugzilla.mozilla.org/show_bug.cgi?id=61911 (fixed)\n      //\n      // 2. HTMLEmbedElement and HTMLObjectElement are be typeof \"function\"\n      //    https://bugzilla.mozilla.org/show_bug.cgi?id=268945 (won't fix)\n      isFunction = buildClassCheck(names[5]);\n\n      // istanbul ignore next\n      isArray = Array.isArray || buildClassCheck(names[6]);\n      isError = buildClassCheck(names[7]);\n\n      isSet = buildClassCheck(names[8], typeof Set !== 'undefined' && Set);\n      isMap = buildClassCheck(names[9], typeof Map !== 'undefined' && Map);\n\n      // Add core types as known so that they can be checked by value below,\n      // notably excluding Functions and adding Arguments and Error.\n      addKnownType('Arguments');\n      addKnownType(names[0]);\n      addKnownType(names[1]);\n      addKnownType(names[2]);\n      addKnownType(names[3]);\n      addKnownType(names[4]);\n      addKnownType(names[6]);\n\n    }\n\n    function addArrayTypes() {\n      var types = 'Int8 Uint8 Uint8Clamped Int16 Uint16 Int32 Uint32 Float32 Float64';\n      forEach(spaceSplit(types), function(str) {\n        addKnownType(str + 'Array');\n      });\n    }\n\n    function addKnownType(className) {\n      var str = '[object '+ className +']';\n      knownTypes[str] = true;\n    }\n\n    function isKnownType(className) {\n      return knownTypes[className];\n    }\n\n    function buildClassCheck(className, globalObject) {\n      // istanbul ignore if\n      if (globalObject && isClass(new globalObject, 'Object')) {\n        return getConstructorClassCheck(globalObject);\n      } else {\n        return getToStringClassCheck(className);\n      }\n    }\n\n    // Map and Set may be [object Object] in certain IE environments.\n    // In this case we need to perform a check using the constructor\n    // instead of Object.prototype.toString.\n    // istanbul ignore next\n    function getConstructorClassCheck(obj) {\n      var ctorStr = String(obj);\n      return function(obj) {\n        return String(obj.constructor) === ctorStr;\n      };\n    }\n\n    function getToStringClassCheck(className) {\n      return function(obj, str) {\n        // perf: Returning up front on instanceof appears to be slower.\n        return isClass(obj, className, str);\n      };\n    }\n\n    function buildPrimitiveClassCheck(className) {\n      var type = className.toLowerCase();\n      return function(obj) {\n        var t = typeof obj;\n        return t === type || t === 'object' && isClass(obj, className);\n      };\n    }\n\n    addCoreTypes();\n    addArrayTypes();\n\n    isSerializable = function(obj, className) {\n      // Only known objects can be serialized. This notably excludes functions,\n      // host objects, Symbols (which are matched by reference), and instances\n      // of classes. The latter can arguably be matched by value, but\n      // distinguishing between these and host objects -- which should never be\n      // compared by value -- is very tricky so not dealing with it here.\n      return isKnownType(className) || isPlainObject(obj, className);\n    };\n\n  }\n\n  function isClass(obj, className, str) {\n    if (!str) {\n      str = classToString(obj);\n    }\n    return str === '[object '+ className +']';\n  }\n\n  // Wrapping the core's \"define\" methods to\n  // save a few bytes in the minified script.\n  function wrapNamespace(method) {\n    return function(sugarNamespace, arg1, arg2) {\n      sugarNamespace[method](arg1, arg2);\n    };\n  }\n\n  // Method define aliases\n  var alias                       = wrapNamespace('alias'),\n      defineStatic                = wrapNamespace('defineStatic'),\n      defineInstance              = wrapNamespace('defineInstance'),\n      defineStaticPolyfill        = wrapNamespace('defineStaticPolyfill'),\n      defineInstancePolyfill      = wrapNamespace('defineInstancePolyfill'),\n      defineInstanceAndStatic     = wrapNamespace('defineInstanceAndStatic'),\n      defineInstanceWithArguments = wrapNamespace('defineInstanceWithArguments');\n\n  function defineInstanceSimilar(sugarNamespace, set, fn, flags) {\n    defineInstance(sugarNamespace, collectSimilarMethods(set, fn), flags);\n  }\n\n  function defineInstanceAndStaticSimilar(sugarNamespace, set, fn, flags) {\n    defineInstanceAndStatic(sugarNamespace, collectSimilarMethods(set, fn), flags);\n  }\n\n  function collectSimilarMethods(set, fn) {\n    var methods = {};\n    if (isString(set)) {\n      set = spaceSplit(set);\n    }\n    forEach(set, function(el, i) {\n      fn(methods, el, i);\n    });\n    return methods;\n  }\n\n  // This song and dance is to fix methods to a different length\n  // from what they actually accept in order to stay in line with\n  // spec. Additionally passing argument length, as some methods\n  // throw assertion errors based on this (undefined check is not\n  // enough). Fortunately for now spec is such that passing 3\n  // actual arguments covers all requirements. Note that passing\n  // the argument length also forces the compiler to not rewrite\n  // length of the compiled function.\n  function fixArgumentLength(fn) {\n    var staticFn = function(a) {\n      var args = arguments;\n      return fn(a, args[1], args[2], args.length - 1);\n    };\n    staticFn.instance = function(b) {\n      var args = arguments;\n      return fn(this, b, args[1], args.length);\n    };\n    return staticFn;\n  }\n\n  function defineAccessor(namespace, name, fn) {\n    setProperty(namespace, name, fn);\n  }\n\n  function defineOptionsAccessor(namespace, defaults) {\n    var obj = simpleClone(defaults);\n\n    function getOption(name) {\n      return obj[name];\n    }\n\n    function setOption(arg1, arg2) {\n      var options;\n      if (arguments.length === 1) {\n        options = arg1;\n      } else {\n        options = {};\n        options[arg1] = arg2;\n      }\n      forEachProperty(options, function(val, name) {\n        if (val === null) {\n          val = defaults[name];\n        }\n        obj[name] = val;\n      });\n    }\n\n    defineAccessor(namespace, 'getOption', getOption);\n    defineAccessor(namespace, 'setOption', setOption);\n    return getOption;\n  }\n\n  // For methods defined directly on the prototype like Range\n  function defineOnPrototype(ctor, methods) {\n    var proto = ctor.prototype;\n    forEachProperty(methods, function(val, key) {\n      proto[key] = val;\n    });\n  }\n\n  // Argument helpers\n\n  function assertArgument(exists) {\n    if (!exists) {\n      throw new TypeError('Argument required');\n    }\n  }\n\n  function assertCallable(obj) {\n    if (!isFunction(obj)) {\n      throw new TypeError('Function is not callable');\n    }\n  }\n\n  function assertArray(obj) {\n    if (!isArray(obj)) {\n      throw new TypeError('Array required');\n    }\n  }\n\n  function assertWritable(obj) {\n    if (isPrimitive(obj)) {\n      // If strict mode is active then primitives will throw an\n      // error when attempting to write properties. We can't be\n      // sure if strict mode is available, so pre-emptively\n      // throw an error here to ensure consistent behavior.\n      throw new TypeError('Property cannot be written');\n    }\n  }\n\n  // Coerces an object to a positive integer.\n  // Does not allow Infinity.\n  function coercePositiveInteger(n) {\n    n = +n || 0;\n    if (n < 0 || !isNumber(n) || !isFinite(n)) {\n      throw new RangeError('Invalid number');\n    }\n    return trunc(n);\n  }\n\n\n  // General helpers\n\n  function isDefined(o) {\n    return o !== undefined;\n  }\n\n  function isUndefined(o) {\n    return o === undefined;\n  }\n\n  function privatePropertyAccessor(key) {\n    var privateKey = PRIVATE_PROP_PREFIX + key;\n    return function(obj, val) {\n      if (arguments.length > 1) {\n        setProperty(obj, privateKey, val);\n        return obj;\n      }\n      return obj[privateKey];\n    };\n  }\n\n  function setChainableConstructor(sugarNamespace, createFn) {\n    sugarNamespace.prototype.constructor = function() {\n      return createFn.apply(this, arguments);\n    };\n  }\n\n  // Fuzzy matching helpers\n\n  function getMatcher(f) {\n    if (!isPrimitive(f)) {\n      var className = classToString(f);\n      if (isRegExp(f, className)) {\n        return regexMatcher(f);\n      } else if (isDate(f, className)) {\n        return dateMatcher(f);\n      } else if (isFunction(f, className)) {\n        return functionMatcher(f);\n      } else if (isPlainObject(f, className)) {\n        return fuzzyMatcher(f);\n      }\n    }\n    // Default is standard isEqual\n    return defaultMatcher(f);\n  }\n\n  function fuzzyMatcher(obj) {\n    var matchers = {};\n    return function(el, i, arr) {\n      var matched = true;\n      if (!isObjectType(el)) {\n        return false;\n      }\n      forEachProperty(obj, function(val, key) {\n        matchers[key] = getOwn(matchers, key) || getMatcher(val);\n        if (matchers[key].call(arr, el[key], i, arr) === false) {\n          matched = false;\n        }\n        return matched;\n      });\n      return matched;\n    };\n  }\n\n  function defaultMatcher(f) {\n    return function(el) {\n      return isEqual(el, f);\n    };\n  }\n\n  function regexMatcher(reg) {\n    reg = RegExp(reg);\n    return function(el) {\n      return reg.test(el);\n    };\n  }\n\n  function dateMatcher(d) {\n    var ms = d.getTime();\n    return function(el) {\n      return !!(el && el.getTime) && el.getTime() === ms;\n    };\n  }\n\n  function functionMatcher(fn) {\n    return function(el, i, arr) {\n      // Return true up front if match by reference\n      return el === fn || fn.call(arr, el, i, arr);\n    };\n  }\n\n  // Object helpers\n\n  function getKeys(obj) {\n    return Object.keys(obj);\n  }\n\n  function deepHasProperty(obj, key, any) {\n    return handleDeepProperty(obj, key, any, true);\n  }\n\n  function deepGetProperty(obj, key, any) {\n    return handleDeepProperty(obj, key, any, false);\n  }\n\n  function deepSetProperty(obj, key, val) {\n    handleDeepProperty(obj, key, false, false, true, false, val);\n    return obj;\n  }\n\n  function handleDeepProperty(obj, key, any, has, fill, fillLast, val) {\n    var ns, bs, ps, cbi, set, isLast, isPush, isIndex, nextIsIndex, exists;\n    ns = obj;\n    if (key == null) return;\n\n    if (isObjectType(key)) {\n      // Allow array and array-like accessors\n      bs = [key];\n    } else {\n      key = String(key);\n      if (key.indexOf('..') !== -1) {\n        return handleArrayIndexRange(obj, key, any, val);\n      }\n      bs = key.split('[');\n    }\n\n    set = isDefined(val);\n\n    for (var i = 0, blen = bs.length; i < blen; i++) {\n      ps = bs[i];\n\n      if (isString(ps)) {\n        ps = periodSplit(ps);\n      }\n\n      for (var j = 0, plen = ps.length; j < plen; j++) {\n        key = ps[j];\n\n        // Is this the last key?\n        isLast = i === blen - 1 && j === plen - 1;\n\n        // Index of the closing ]\n        cbi = key.indexOf(']');\n\n        // Is the key an array index?\n        isIndex = cbi !== -1;\n\n        // Is this array push syntax \"[]\"?\n        isPush = set && cbi === 0;\n\n        // If the bracket split was successful and this is the last element\n        // in the dot split, then we know the next key will be an array index.\n        nextIsIndex = blen > 1 && j === plen - 1;\n\n        if (isPush) {\n          // Set the index to the end of the array\n          key = ns.length;\n        } else if (isIndex) {\n          // Remove the closing ]\n          key = key.slice(0, -1);\n        }\n\n        // If the array index is less than 0, then\n        // add its length to allow negative indexes.\n        if (isIndex && key < 0) {\n          key = +key + ns.length;\n        }\n\n        // Bracket keys may look like users[5] or just [5], so the leading\n        // characters are optional. We can enter the namespace if this is the\n        // 2nd part, if there is only 1 part, or if there is an explicit key.\n        if (i || key || blen === 1) {\n\n          // TODO: need to be sure this check handles ''.length when\n          // we refactor.\n          exists = any ? key in Object(ns) : hasOwn(ns, key);\n\n          // Non-existent namespaces are only filled if they are intermediate\n          // (not at the end) or explicitly filling the last.\n          if (fill && (!isLast || fillLast) && !exists) {\n            // For our purposes, last only needs to be an array.\n            ns = ns[key] = nextIsIndex || (fillLast && isLast) ? [] : {};\n            continue;\n          }\n\n          if (has) {\n            if (isLast || !exists) {\n              return exists;\n            }\n          } else if (set && isLast) {\n            assertWritable(ns);\n            ns[key] = val;\n          }\n\n          ns = exists ? ns[key] : undefined;\n        }\n\n      }\n    }\n    return ns;\n  }\n\n  // Get object property with support for 0..1 style range notation.\n  function handleArrayIndexRange(obj, key, any, val) {\n    var match, start, end, leading, trailing, arr, set;\n    match = key.match(PROPERTY_RANGE_REG);\n    if (!match) {\n      return;\n    }\n\n    set = isDefined(val);\n    leading = match[1];\n\n    if (leading) {\n      arr = handleDeepProperty(obj, leading, any, false, set ? true : false, true);\n    } else {\n      arr = obj;\n    }\n\n    assertArray(arr);\n\n    trailing = match[4];\n    start    = match[2] ? +match[2] : 0;\n    end      = match[3] ? +match[3] : arr.length;\n\n    // A range of 0..1 is inclusive, so we need to add 1 to the end. If this\n    // pushes the index from -1 to 0, then set it to the full length of the\n    // array, otherwise it will return nothing.\n    end = end === -1 ? arr.length : end + 1;\n\n    if (set) {\n      for (var i = start; i < end; i++) {\n        handleDeepProperty(arr, i + trailing, any, false, true, false, val);\n      }\n    } else {\n      arr = arr.slice(start, end);\n\n      // If there are trailing properties, then they need to be mapped for each\n      // element in the array.\n      if (trailing) {\n        if (trailing.charAt(0) === HALF_WIDTH_PERIOD) {\n          // Need to chomp the period if one is trailing after the range. We\n          // can't do this at the regex level because it will be required if\n          // we're setting the value as it needs to be concatentated together\n          // with the array index to be set.\n          trailing = trailing.slice(1);\n        }\n        return map(arr, function(el) {\n          return handleDeepProperty(el, trailing);\n        });\n      }\n    }\n    return arr;\n  }\n\n  function getOwnKey(obj, key) {\n    if (hasOwn(obj, key)) {\n      return key;\n    }\n  }\n\n  function hasProperty(obj, prop) {\n    return !isPrimitive(obj) && prop in obj;\n  }\n\n  function isObjectType(obj, type) {\n    return !!obj && (type || typeof obj) === 'object';\n  }\n\n  function isPrimitive(obj, type) {\n    type = type || typeof obj;\n    return obj == null || type === 'string' || type === 'number' || type === 'boolean';\n  }\n\n  function isPlainObject(obj, className) {\n    return isObjectType(obj) &&\n           isClass(obj, 'Object', className) &&\n           hasValidPlainObjectPrototype(obj) &&\n           hasOwnEnumeratedProperties(obj);\n  }\n\n  function hasValidPlainObjectPrototype(obj) {\n    var hasToString = 'toString' in obj;\n    var hasConstructor = 'constructor' in obj;\n    // An object created with Object.create(null) has no methods in the\n    // prototype chain, so check if any are missing. The additional hasToString\n    // check is for false positives on some host objects in old IE which have\n    // toString but no constructor. If the object has an inherited constructor,\n    // then check if it is Object (the \"isPrototypeOf\" tapdance here is a more\n    // robust way of ensuring this if the global has been hijacked). Note that\n    // accessing the constructor directly (without \"in\" or \"hasOwnProperty\")\n    // will throw a permissions error in IE8 on cross-domain windows.\n    return (!hasConstructor && !hasToString) ||\n            (hasConstructor && !hasOwn(obj, 'constructor') &&\n             hasOwn(obj.constructor.prototype, 'isPrototypeOf'));\n  }\n\n  function hasOwnEnumeratedProperties(obj) {\n    // Plain objects are generally defined as having enumerated properties\n    // all their own, however in early IE environments without defineProperty,\n    // there may also be enumerated methods in the prototype chain, so check\n    // for both of these cases.\n    var objectProto = Object.prototype;\n    for (var key in obj) {\n      var val = obj[key];\n      if (!hasOwn(obj, key) && val !== objectProto[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function simpleRepeat(n, fn) {\n    for (var i = 0; i < n; i++) {\n      fn(i);\n    }\n  }\n\n  function simpleClone(obj) {\n    return simpleMerge({}, obj);\n  }\n\n  // TODO: Use Object.assign here going forward.\n  function simpleMerge(target, source) {\n    forEachProperty(source, function(val, key) {\n      target[key] = val;\n    });\n    return target;\n  }\n\n  // Make primtives types like strings into objects.\n  function coercePrimitiveToObject(obj) {\n    if (isPrimitive(obj)) {\n      obj = Object(obj);\n    }\n    // istanbul ignore next\n    if (NO_KEYS_IN_STRING_OBJECTS && isString(obj)) {\n      forceStringCoercion(obj);\n    }\n    return obj;\n  }\n\n  // Force strings to have their indexes set in\n  // environments that don't do this automatically.\n  // istanbul ignore next\n  function forceStringCoercion(obj) {\n    var i = 0, chr;\n    while (chr = obj.charAt(i)) {\n      obj[i++] = chr;\n    }\n  }\n\n  // Equality helpers\n\n  // Perf\n  function isEqual(a, b, stack) {\n    var aClass, bClass;\n    if (a === b) {\n      // Return quickly up front when matched by reference,\n      // but be careful about 0 !== -0.\n      return a !== 0 || 1 / a === 1 / b;\n    }\n    aClass = classToString(a);\n    bClass = classToString(b);\n    if (aClass !== bClass) {\n      return false;\n    }\n\n    if (isSerializable(a, aClass) && isSerializable(b, bClass)) {\n      return objectIsEqual(a, b, aClass, stack);\n    } else if (isSet(a, aClass) && isSet(b, bClass)) {\n      return a.size === b.size && isEqual(setToArray(a), setToArray(b), stack);\n    } else if (isMap(a, aClass) && isMap(b, bClass)) {\n      return a.size === b.size && isEqual(mapToArray(a), mapToArray(b), stack);\n    } else if (isError(a, aClass) && isError(b, bClass)) {\n      return a.toString() === b.toString();\n    }\n\n    return false;\n  }\n\n  // Perf\n  function objectIsEqual(a, b, aClass, stack) {\n    var aType = typeof a, bType = typeof b, propsEqual, count;\n    if (aType !== bType) {\n      return false;\n    }\n    if (isObjectType(a.valueOf())) {\n      if (a.length !== b.length) {\n        // perf: Quickly returning up front for arrays.\n        return false;\n      }\n      count = 0;\n      propsEqual = true;\n      iterateWithCyclicCheck(a, false, stack, function(key, val, cyc, stack) {\n        if (!cyc && (!(key in b) || !isEqual(val, b[key], stack))) {\n          propsEqual = false;\n        }\n        count++;\n        return propsEqual;\n      });\n      if (!propsEqual || count !== getKeys(b).length) {\n        return false;\n      }\n    }\n    // Stringifying the value handles NaN, wrapped primitives, dates, and errors in one go.\n    return a.valueOf().toString() === b.valueOf().toString();\n  }\n\n  // Serializes an object in a way that will provide a token unique\n  // to the type, class, and value of an object. Host objects, class\n  // instances etc, are not serializable, and are held in an array\n  // of references that will return the index as a unique identifier\n  // for the object. This array is passed from outside so that the\n  // calling function can decide when to dispose of this array.\n  function serializeInternal(obj, refs, stack) {\n    var type = typeof obj, sign = '', className, value, ref;\n\n    // Return up front on\n    if (1 / obj === -Infinity) {\n      sign = '-';\n    }\n\n    // Return quickly for primitives to save cycles\n    if (isPrimitive(obj, type) && !isRealNaN(obj)) {\n      return type + sign + obj;\n    }\n\n    className = classToString(obj);\n\n    if (!isSerializable(obj, className)) {\n      ref = indexOf(refs, obj);\n      if (ref === -1) {\n        ref = refs.length;\n        refs.push(obj);\n      }\n      return ref;\n    } else if (isObjectType(obj)) {\n      value = serializeDeep(obj, refs, stack) + obj.toString();\n    } else if (obj.valueOf) {\n      value = obj.valueOf();\n    }\n    return type + className + sign + value;\n  }\n\n  function serializeDeep(obj, refs, stack) {\n    var result = '';\n    iterateWithCyclicCheck(obj, true, stack, function(key, val, cyc, stack) {\n      result += cyc ? 'CYC' : key + serializeInternal(val, refs, stack);\n    });\n    return result;\n  }\n\n  function iterateWithCyclicCheck(obj, sortedKeys, stack, fn) {\n\n    function next(val, key) {\n      var cyc = false;\n\n      // Allowing a step into the structure before triggering this check to save\n      // cycles on standard JSON structures and also to try as hard as possible to\n      // catch basic properties that may have been modified.\n      if (stack.length > 1) {\n        var i = stack.length;\n        while (i--) {\n          if (stack[i] === val) {\n            cyc = true;\n          }\n        }\n      }\n\n      stack.push(val);\n      fn(key, val, cyc, stack);\n      stack.pop();\n    }\n\n    function iterateWithSortedKeys() {\n      // Sorted keys is required for serialization, where object order\n      // does not matter but stringified order does.\n      var arr = getKeys(obj).sort(), key;\n      for (var i = 0; i < arr.length; i++) {\n        key = arr[i];\n        next(obj[key], arr[i]);\n      }\n    }\n\n    // This method for checking for cyclic structures was egregiously stolen from\n    // the ingenious method by @kitcambridge from the Underscore script:\n    // https://github.com/documentcloud/underscore/issues/240\n    if (!stack) {\n      stack = [];\n    }\n\n    if (sortedKeys) {\n      iterateWithSortedKeys();\n    } else {\n      forEachProperty(obj, next);\n    }\n  }\n\n\n  // Array helpers\n\n  function isArrayIndex(n) {\n    return n >>> 0 == n && n != 0xFFFFFFFF;\n  }\n\n  function iterateOverSparseArray(arr, fn, fromIndex, loop) {\n    var indexes = getSparseArrayIndexes(arr, fromIndex, loop), index;\n    for (var i = 0, len = indexes.length; i < len; i++) {\n      index = indexes[i];\n      fn.call(arr, arr[index], index, arr);\n    }\n    return arr;\n  }\n\n  // It's unclear whether or not sparse arrays qualify as \"simple enumerables\".\n  // If they are not, however, the wrapping function will be deoptimized, so\n  // isolate here (also to share between es5 and array modules).\n  function getSparseArrayIndexes(arr, fromIndex, loop, fromRight) {\n    var indexes = [], i;\n    for (i in arr) {\n      // istanbul ignore next\n      if (isArrayIndex(i) && (loop || (fromRight ? i <= fromIndex : i >= fromIndex))) {\n        indexes.push(+i);\n      }\n    }\n    indexes.sort(function(a, b) {\n      var aLoop = a > fromIndex;\n      var bLoop = b > fromIndex;\n      // This block cannot be reached unless ES5 methods are being shimmed.\n      // istanbul ignore if\n      if (aLoop !== bLoop) {\n        return aLoop ? -1 : 1;\n      }\n      return a - b;\n    });\n    return indexes;\n  }\n\n  function getEntriesForIndexes(obj, find, loop, isString) {\n    var result, length = obj.length;\n    if (!isArray(find)) {\n      return entryAtIndex(obj, find, length, loop, isString);\n    }\n    result = new Array(find.length);\n    forEach(find, function(index, i) {\n      result[i] = entryAtIndex(obj, index, length, loop, isString);\n    });\n    return result;\n  }\n\n  function getNormalizedIndex(index, length, loop) {\n    if (index && loop) {\n      index = index % length;\n    }\n    if (index < 0) index = length + index;\n    return index;\n  }\n\n  function entryAtIndex(obj, index, length, loop, isString) {\n    index = getNormalizedIndex(index, length, loop);\n    return isString ? obj.charAt(index) : obj[index];\n  }\n\n  function mapWithShortcuts(el, f, context, mapArgs) {\n    if (!f) {\n      return el;\n    } else if (f.apply) {\n      return f.apply(context, mapArgs);\n    } else if (isArray(f)) {\n      return map(f, function(m) {\n        return mapWithShortcuts(el, m, context, mapArgs);\n      });\n    } else if (isFunction(el[f])) {\n      return el[f].call(el);\n    } else {\n      return deepGetProperty(el, f, true);\n    }\n  }\n\n  function spaceSplit(str) {\n    return str.split(' ');\n  }\n\n  function commaSplit(str) {\n    return str.split(HALF_WIDTH_COMMA);\n  }\n\n  function periodSplit(str) {\n    return str.split(HALF_WIDTH_PERIOD);\n  }\n\n  function forEach(arr, fn) {\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (!(i in arr)) {\n        return iterateOverSparseArray(arr, fn, i);\n      }\n      fn(arr[i], i);\n    }\n  }\n\n  function filter(arr, fn) {\n    var result = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n      var el = arr[i];\n      if (i in arr && fn(el, i)) {\n        result.push(el);\n      }\n    }\n    return result;\n  }\n\n  function map(arr, fn) {\n    // perf: Not using fixed array len here as it may be sparse.\n    var result = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (i in arr) {\n        result.push(fn(arr[i], i));\n      }\n    }\n    return result;\n  }\n\n  function indexOf(arr, el) {\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (i in arr && arr[i] === el) return i;\n    }\n    return -1;\n  }\n\n  // Number helpers\n\n  // istanbul ignore next\n  var trunc = Math.trunc || function(n) {\n    if (n === 0 || !isFinite(n)) return n;\n    return n < 0 ? ceil(n) : floor(n);\n  };\n\n  function isRealNaN(obj) {\n    // This is only true of NaN\n    return obj != null && obj !== obj;\n  }\n\n  function withPrecision(val, precision, fn) {\n    var multiplier = pow(10, abs(precision || 0));\n    fn = fn || round;\n    if (precision < 0) multiplier = 1 / multiplier;\n    return fn(val * multiplier) / multiplier;\n  }\n\n  function padNumber(num, place, sign, base, replacement) {\n    var str = abs(num).toString(base || 10);\n    str = repeatString(replacement || '0', place - str.replace(/\\.\\d+/, '').length) + str;\n    if (sign || num < 0) {\n      str = (num < 0 ? '-' : '+') + str;\n    }\n    return str;\n  }\n\n  function getOrdinalSuffix(num) {\n    if (num >= 11 && num <= 13) {\n      return 'th';\n    } else {\n      switch(num % 10) {\n        case 1:  return 'st';\n        case 2:  return 'nd';\n        case 3:  return 'rd';\n        default: return 'th';\n      }\n    }\n  }\n\n  // Fullwidth number helpers\n  var fullWidthNumberReg, fullWidthNumberMap, fullWidthNumbers;\n\n  function buildFullWidthNumber() {\n    var fwp = FULL_WIDTH_PERIOD, hwp = HALF_WIDTH_PERIOD, hwc = HALF_WIDTH_COMMA, fwn = '';\n    fullWidthNumberMap = {};\n    for (var i = 0, digit; i <= 9; i++) {\n      digit = chr(i + FULL_WIDTH_ZERO);\n      fwn += digit;\n      fullWidthNumberMap[digit] = chr(i + HALF_WIDTH_ZERO);\n    }\n    fullWidthNumberMap[hwc] = '';\n    fullWidthNumberMap[fwp] = hwp;\n    // Mapping this to itself to capture it easily\n    // in stringToNumber to detect decimals later.\n    fullWidthNumberMap[hwp] = hwp;\n    fullWidthNumberReg = allCharsReg(fwn + fwp + hwc + hwp);\n    fullWidthNumbers = fwn;\n  }\n\n  // Takes into account full-width characters, commas, and decimals.\n  function stringToNumber(str, base) {\n    var sanitized, isDecimal;\n    sanitized = str.replace(fullWidthNumberReg, function(chr) {\n      var replacement = getOwn(fullWidthNumberMap, chr);\n      if (replacement === HALF_WIDTH_PERIOD) {\n        isDecimal = true;\n      }\n      return replacement;\n    });\n    return isDecimal ? parseFloat(sanitized) : parseInt(sanitized, base || 10);\n  }\n\n  // Math aliases\n  var abs   = Math.abs,\n      pow   = Math.pow,\n      min   = Math.min,\n      max   = Math.max,\n      ceil  = Math.ceil,\n      floor = Math.floor,\n      round = Math.round;\n\n\n  // String helpers\n\n  var chr = String.fromCharCode;\n\n  function trim(str) {\n    return str.trim();\n  }\n\n  function repeatString(str, num) {\n    var result = '';\n    str = str.toString();\n    while (num > 0) {\n      if (num & 1) {\n        result += str;\n      }\n      if (num >>= 1) {\n        str += str;\n      }\n    }\n    return result;\n  }\n\n  function simpleCapitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function createFormatMatcher(bracketMatcher, percentMatcher, precheck) {\n\n    var reg = STRING_FORMAT_REG;\n    var compileMemoized = memoizeFunction(compile);\n\n    function getToken(format, match) {\n      var get, token, literal, fn;\n      var bKey = match[2];\n      var pLit = match[3];\n      var pKey = match[5];\n      if (match[4] && percentMatcher) {\n        token = pKey;\n        get = percentMatcher;\n      } else if (bKey) {\n        token = bKey;\n        get = bracketMatcher;\n      } else if (pLit && percentMatcher) {\n        literal = pLit;\n      } else {\n        literal = match[1] || match[0];\n      }\n      if (get) {\n        assertPassesPrecheck(precheck, bKey, pKey);\n        fn = function(obj, opt) {\n          return get(obj, token, opt);\n        };\n      }\n      format.push(fn || getLiteral(literal));\n    }\n\n    function getSubstring(format, str, start, end) {\n      if (end > start) {\n        var sub = str.slice(start, end);\n        assertNoUnmatched(sub, OPEN_BRACE);\n        assertNoUnmatched(sub, CLOSE_BRACE);\n        format.push(function() {\n          return sub;\n        });\n      }\n    }\n\n    function getLiteral(str) {\n      return function() {\n        return str;\n      };\n    }\n\n    function assertPassesPrecheck(precheck, bt, pt) {\n      if (precheck && !precheck(bt, pt)) {\n        throw new TypeError('Invalid token '+ (bt || pt) +' in format string');\n      }\n    }\n\n    function assertNoUnmatched(str, chr) {\n      if (str.indexOf(chr) !== -1) {\n        throw new TypeError('Unmatched '+ chr +' in format string');\n      }\n    }\n\n    function compile(str) {\n      var format = [], lastIndex = 0, match;\n      reg.lastIndex = 0;\n      while(match = reg.exec(str)) {\n        getSubstring(format, str, lastIndex, match.index);\n        getToken(format, match);\n        lastIndex = reg.lastIndex;\n      }\n      getSubstring(format, str, lastIndex, str.length);\n      return format;\n    }\n\n    return function(str, obj, opt) {\n      var format = compileMemoized(str), result = '';\n      for (var i = 0; i < format.length; i++) {\n        result += format[i](obj, opt);\n      }\n      return result;\n    };\n  }\n\n  // Inflection helper\n\n  var Inflections = {};\n\n  function getAcronym(str) {\n    // istanbul ignore next\n    return Inflections.acronyms && Inflections.acronyms.find(str);\n  }\n\n  function getHumanWord(str) {\n    // istanbul ignore next\n    return Inflections.human && Inflections.human.find(str);\n  }\n\n  function runHumanRules(str) {\n    // istanbul ignore next\n    return Inflections.human && Inflections.human.runRules(str) || str;\n  }\n\n  // RegExp helpers\n\n  function allCharsReg(src) {\n    return RegExp('[' + src + ']', 'g');\n  }\n\n  function getRegExpFlags(reg, add) {\n    var flags = '';\n    add = add || '';\n    function checkFlag(prop, flag) {\n      if (prop || add.indexOf(flag) > -1) {\n        flags += flag;\n      }\n    }\n    checkFlag(reg.global, 'g');\n    checkFlag(reg.ignoreCase, 'i');\n    checkFlag(reg.multiline, 'm');\n    checkFlag(reg.sticky, 'y');\n    return flags;\n  }\n\n  function escapeRegExp(str) {\n    if (!isString(str)) str = String(str);\n    return str.replace(/([\\\\/'*+?|()[\\]{}.^$-])/g,'\\\\$1');\n  }\n\n  // Date helpers\n\n  var _utc = privatePropertyAccessor('utc');\n\n  function callDateGet(d, method) {\n    return d['get' + (_utc(d) ? 'UTC' : '') + method]();\n  }\n\n  function callDateSet(d, method, value, safe) {\n    // \"Safe\" denotes not setting the date if the value is the same as what is\n    // currently set. In theory this should be a noop, however it will cause\n    // timezone shifts when in the middle of a DST fallback. This is unavoidable\n    // as the notation itself is ambiguous (i.e. there are two \"1:00ams\" on\n    // November 1st, 2015 in northern hemisphere timezones that follow DST),\n    // however when advancing or rewinding dates this can throw off calculations\n    // so avoiding this unintentional shifting on an opt-in basis.\n    if (safe && value === callDateGet(d, method, value)) {\n      return;\n    }\n    d['set' + (_utc(d) ? 'UTC' : '') + method](value);\n  }\n\n  // Memoization helpers\n\n  var INTERNAL_MEMOIZE_LIMIT = 1000;\n\n  // Note that attemps to consolidate this with Function#memoize\n  // ended up clunky as that is also serializing arguments. Separating\n  // these implementations turned out to be simpler.\n  function memoizeFunction(fn) {\n    var memo = {}, counter = 0;\n\n    return function(key) {\n      if (hasOwn(memo, key)) {\n        return memo[key];\n      }\n      // istanbul ignore if\n      if (counter === INTERNAL_MEMOIZE_LIMIT) {\n        memo = {};\n        counter = 0;\n      }\n      counter++;\n      return memo[key] = fn(key);\n    };\n  }\n\n  // ES6 helpers\n\n  function setToArray(set) {\n    var arr = new Array(set.size), i = 0;\n    set.forEach(function(val) {\n      arr[i++] = val;\n    });\n    return arr;\n  }\n\n  function mapToArray(map) {\n    var arr = new Array(map.size), i = 0;\n    map.forEach(function(val, key) {\n      arr[i++] = [key, val];\n    });\n    return arr;\n  }\n\n  buildClassChecks();\n  buildFullWidthNumber();\n\n  /***\n   * @module ES5\n   * @description Functions and polyfill methods that fix ES5 functionality. This\n   *              module is excluded from default builds, and can be included if\n   *              you need legacy browser support (IE8 and below).\n   *\n   ***/\n\n  // Non-enumerable properties on Object.prototype. In early JScript implementations\n  // (< IE9) these will shadow object properties and break for..in loops.\n  var DONT_ENUM_PROPS = [\n    'valueOf',\n    'toString',\n    'constructor',\n    'isPrototypeOf',\n    'hasOwnProperty',\n    'toLocaleString',\n    'propertyIsEnumerable'\n  ];\n\n  /***\n   * @fix\n   * @short Fixes DontEnum bug for iteration methods in < IE9.\n   ***/\n  function buildDontEnumFix() {\n    if (!({toString:1}).propertyIsEnumerable('toString')) {\n      var forEachEnumerableProperty = forEachProperty;\n      forEachProperty = function(obj, fn) {\n        forEachEnumerableProperty(obj, fn);\n        for (var i = 0, key; key = DONT_ENUM_PROPS[i]; i++) {\n          if (hasOwn(obj, key)) {\n            if(fn.call(obj, obj[key], key, obj) === false) break;\n          }\n        }\n      };\n    }\n  }\n\n  /***\n   * @fix\n   * @short Adds native methods to chainables in < IE9.\n   ***/\n  function buildChainableNativeMethodsFix() {\n    if (!Object.getOwnPropertyNames) {\n      defineNativeMethodsOnChainable();\n    }\n  }\n\n  // Polyfilled methods will automatically be added to the chainable prototype.\n  // However, Object.getOwnPropertyNames cannot be shimmed for non-enumerable\n  // properties, so if it does not exist, then the only way to access native\n  // methods previous to ES5 is to provide them as a list of tokens here.\n  function defineNativeMethodsOnChainable() {\n\n    var nativeTokens = {\n      'Function': 'apply,call',\n      'RegExp':   'compile,exec,test',\n      'Number':   'toExponential,toFixed,toLocaleString,toPrecision',\n      'Object':   'hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString',\n      'Array':    'concat,join,pop,push,reverse,shift,slice,sort,splice,toLocaleString,unshift',\n      'Date':     'getTime,getTimezoneOffset,setTime,toDateString,toGMTString,toLocaleDateString,toLocaleString,toLocaleTimeString,toTimeString,toUTCString',\n      'String':   'anchor,big,blink,bold,charAt,charCodeAt,concat,fixed,fontcolor,fontsize,indexOf,italics,lastIndexOf,link,localeCompare,match,replace,search,slice,small,split,strike,sub,substr,substring,sup,toLocaleLowerCase,toLocaleUpperCase,toLowerCase,toUpperCase'\n    };\n\n    var dateTokens = 'FullYear,Month,Date,Hours,Minutes,Seconds,Milliseconds'.split(',');\n\n    function addDateTokens(prefix, arr) {\n      for (var i = 0; i < dateTokens.length; i++) {\n        arr.push(prefix + dateTokens[i]);\n      }\n    }\n\n    forEachProperty(nativeTokens, function(str, name) {\n      var tokens = str.split(',');\n      if (name === 'Date') {\n        addDateTokens('get', tokens);\n        addDateTokens('set', tokens);\n        addDateTokens('getUTC', tokens);\n        addDateTokens('setUTC', tokens);\n      }\n      tokens.push('toString');\n      mapNativeToChainable(name, tokens);\n    });\n\n  }\n\n\n  buildDontEnumFix();\n  buildChainableNativeMethodsFix();\n\n\n  /*** @namespace Object ***/\n\n  function assertNonNull(obj) {\n    if (obj == null) {\n      throw new TypeError('Object required');\n    }\n  }\n\n  defineStaticPolyfill(sugarObject, {\n\n    'keys': function(obj) {\n      var keys = [];\n      assertNonNull(obj);\n      forEachProperty(coercePrimitiveToObject(obj), function(val, key) {\n        keys.push(key);\n      });\n      return keys;\n    }\n\n  });\n\n\n  /*** @namespace Array ***/\n\n  function arrayIndexOf(arr, search, fromIndex, fromRight) {\n    var length = arr.length, defaultFromIndex, index, increment;\n\n    increment = fromRight ? -1 : 1;\n    defaultFromIndex = fromRight ? length - 1 : 0;\n    fromIndex = trunc(fromIndex);\n    if (!fromIndex && fromIndex !== 0) {\n      fromIndex = defaultFromIndex;\n    }\n    if (fromIndex < 0) {\n      fromIndex = length + fromIndex;\n    }\n    if ((!fromRight && fromIndex < 0) || (fromRight && fromIndex >= length)) {\n      fromIndex = defaultFromIndex;\n    }\n\n    index = fromIndex;\n\n    while((fromRight && index >= 0) || (!fromRight && index < length)) {\n      if (!(index in arr)) {\n        return sparseIndexOf(arr, search, fromIndex, fromRight);\n      }\n      if (isArrayIndex(index) && arr[index] === search) {\n        return index;\n      }\n      index += increment;\n    }\n    return -1;\n  }\n\n  function sparseIndexOf(arr, search, fromIndex, fromRight) {\n    var indexes = getSparseArrayIndexes(arr, fromIndex, false, fromRight), index;\n    indexes.sort(function(a, b) {\n      return fromRight ? b - a : a - b;\n    });\n    while ((index = indexes.shift()) !== undefined) {\n      if (arr[index] === search) {\n        return +index;\n      }\n    }\n    return -1;\n  }\n\n  function arrayReduce(arr, fn, initialValue, fromRight) {\n    var length = arr.length, count = 0, defined = isDefined(initialValue), result, index;\n    assertCallable(fn);\n    if (length == 0 && !defined) {\n      throw new TypeError('Reduce called on empty array with no initial value');\n    } else if (defined) {\n      result = initialValue;\n    } else {\n      result = arr[fromRight ? length - 1 : count];\n      count++;\n    }\n    while(count < length) {\n      index = fromRight ? length - count - 1 : count;\n      if (index in arr) {\n        result = fn(result, arr[index], index, arr);\n      }\n      count++;\n    }\n    return result;\n  }\n\n  defineStaticPolyfill(sugarArray, {\n\n    /***\n     *\n     * @method isArray(obj)\n     * @returns Boolean\n     * @polyfill ES5\n     * @static\n     * @short Returns true if `obj` is an Array.\n     *\n     * @example\n     *\n     *   Array.isArray(3)        -> false\n     *   Array.isArray(true)     -> false\n     *   Array.isArray('wasabi') -> false\n     *   Array.isArray([1,2,3])  -> true\n     *\n     ***/\n    'isArray': function(obj) {\n      return isArray(obj);\n    }\n\n  });\n\n  defineInstancePolyfill(sugarArray, {\n\n    'every': function(fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      var length = this.length, index = 0;\n      assertCallable(fn);\n      while(index < length) {\n        if (index in this && !fn.call(context, this[index], index, this)) {\n          return false;\n        }\n        index++;\n      }\n      return true;\n    },\n\n    'some': function(fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      var length = this.length, index = 0;\n      assertCallable(fn);\n      while(index < length) {\n        if (index in this && fn.call(context, this[index], index, this)) {\n          return true;\n        }\n        index++;\n      }\n      return false;\n    },\n\n    'map': function(fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      var length = this.length, index = 0, result = new Array(length);\n      assertCallable(fn);\n      while(index < length) {\n        if (index in this) {\n          result[index] = fn.call(context, this[index], index, this);\n        }\n        index++;\n      }\n      return result;\n    },\n\n    'filter': function(fn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      var length = this.length, index = 0, result = [];\n      assertCallable(fn);\n      while(index < length) {\n        if (index in this && fn.call(context, this[index], index, this)) {\n          result.push(this[index]);\n        }\n        index++;\n      }\n      return result;\n    },\n\n    /***\n     * @method indexOf(search, [fromIndex] = 0)\n     * @returns Number\n     * @polyfill ES5\n     * @short Searches the array and returns the first index where `search` occurs,\n     *        or `-1` if the element is not found.\n     * @extra [fromIndex] is the index from which to begin the search. This\n     *        method performs a simple strict equality comparison on `search`.\n     *        Sugar does not enhance this method to support `enhanced matching`.\n     *        For such functionality, use the `findIndex` method instead.\n     *\n     * @example\n     *\n     *   [1,2,3].indexOf(3) -> 1\n     *   [1,2,3].indexOf(7) -> -1\n     *\n     ***/\n    'indexOf': function(search) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, fromIndex = arguments[1];\n      if (isString(this)) return this.indexOf(search, fromIndex);\n      return arrayIndexOf(this, search, fromIndex);\n    },\n\n    /***\n     * @method lastIndexOf(search, [fromIndex] = array.length - 1)\n     * @returns Number\n     * @polyfill ES5\n     * @short Searches the array from the end and returns the first index where\n     *        `search` occurs, or `-1` if the element is not found.\n     * @extra [fromIndex] is the index from which to begin the search. This method\n     *        performs a simple strict equality comparison on `search`.\n     *        Sugar does not enhance this method to support `enhanced matching`.\n     *\n     * @example\n     *\n     *   [1,2,1].lastIndexOf(1) -> 2\n     *   [1,2,1].lastIndexOf(7) -> -1\n     *\n     ***/\n    'lastIndexOf': function(search) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, fromIndex = arguments[1];\n      if (isString(this)) return this.lastIndexOf(search, fromIndex);\n      return arrayIndexOf(this, search, fromIndex, true);\n    },\n\n    /***\n     * @method forEach([eachFn], [context])\n     * @polyfill ES5\n     * @short Iterates over the array, calling [eachFn] on each loop.\n     * @extra [context] becomes the `this` object.\n     *\n     * @callback eachFn\n     *\n     *   el   The element of the current iteration.\n     *   i    The index of the current iteration.\n     *   arr  A reference to the array.\n     *\n     * @example\n     *\n     *   ['a','b','c'].forEach(function(a) {\n     *     // Called 3 times: 'a','b','c'\n     *   });\n     *\n     ***/\n    'forEach': function(eachFn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      var length = this.length, index = 0;\n      assertCallable(eachFn);\n      while(index < length) {\n        if (index in this) {\n          eachFn.call(context, this[index], index, this);\n        }\n        index++;\n      }\n    },\n\n    /***\n     * @method reduce(reduceFn, [init])\n     * @returns Mixed\n     * @polyfill ES5\n     * @short Reduces the array to a single result.\n     * @extra This operation is sometimes called \"accumulation\", as it takes the\n     *        result of the last iteration of `reduceFn` and passes it as the first\n     *        argument to the next iteration, \"accumulating\" that value as it goes.\n     *        The return value of this method will be the return value of the final\n     *        iteration of `reduceFn`. If [init] is passed, it will be the initial\n     *        \"accumulator\" (the first argument). If [init] is not passed, then it\n     *        will take the first element in the array, and `reduceFn` will not be\n     *        called for that element.\n     *\n     * @callback reduceFn\n     *\n     *   acc  The \"accumulator\". Either [init], the result of the last iteration\n     *        of `reduceFn`, or the first element of the array.\n     *   el   The current element for this iteration.\n     *   idx  The current index for this iteration.\n     *   arr  A reference to the array.\n     *\n     * @example\n     *\n     *   [1,2,3].reduce(function(a, b) {\n     *     return a - b; // 1 - 2 - 3\n     *   });\n     *\n     *   [1,2,3].reduce(function(a, b) {\n     *     return a - b; // 100 - 1 - 2 - 3\n     *   }, 100);\n     *\n     ***/\n    'reduce': function(reduceFn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      return arrayReduce(this, reduceFn, context);\n    },\n\n    /***\n     * @method reduceRight([reduceFn], [init])\n     * @returns Mixed\n     * @polyfill ES5\n     * @short Similar to `Array#reduce`, but operates on the elements in reverse.\n     *\n     * @callback reduceFn\n     *\n     *   acc  The \"accumulator\", either [init], the result of the last iteration\n     *        of `reduceFn`, or the last element of the array.\n     *   el   The current element for this iteration.\n     *   idx  The current index for this iteration.\n     *   arr  A reference to the array.\n     *\n     * @example\n     *\n     *   [1,2,3].reduceRight(function(a, b) {\n     *     return a - b; // 3 - 2 - 1\n     *   });\n     *\n     *   [1,2,3].reduceRight(function(a, b) {\n     *     return a - b; // 100 - 3 - 2 - 1\n     *   }, 100);\n     *\n     *\n     ***/\n    'reduceRight': function(reduceFn) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length, context = arguments[1];\n      return arrayReduce(this, reduceFn, context, true);\n    }\n\n  });\n\n\n  /*** @namespace String ***/\n\n  var TRIM_REG = RegExp('^[' + TRIM_CHARS + ']+|['+ TRIM_CHARS +']+$', 'g');\n\n  defineInstancePolyfill(sugarString, {\n    /***\n     * @method trim()\n     * @returns String\n     * @polyfill ES5\n     * @short Removes leading and trailing whitespace from the string.\n     * @extra Whitespace is defined as line breaks, tabs, and any character in the\n     *        \"Space, Separator\" Unicode category, conforming to the the ES5 spec.\n     *\n     * @example\n     *\n     *   '   wasabi   '.trim()      -> 'wasabi'\n     *   '   wasabi   '.trimLeft()  -> 'wasabi   '\n     *   '   wasabi   '.trimRight() -> '   wasabi'\n     *\n     ***/\n    'trim': function() {\n      return this.toString().replace(TRIM_REG, '');\n    }\n  });\n\n\n  /*** @namespace Function ***/\n\n  defineInstancePolyfill(sugarFunction, {\n\n     /***\n     * @method bind(context, [arg1], ...)\n     * @returns Function\n     * @polyfill ES5\n     * @short Binds `context` as the `this` object for the function when it is\n     *        called. Also allows currying an unlimited number of parameters.\n     * @extra \"currying\" means setting parameters ([arg1], [arg2], etc.) ahead of\n     *        time so that they are passed when the function is called later. If\n     *        you pass additional parameters when the function is actually called,\n     *        they will be added to the end of the curried parameters.\n     *\n     * @example\n     *\n     *   logThis.bind('woof')()   -> logs 'woof' as its this object\n     *   addArgs.bind(1, 2, 3)()  -> returns 5 with 1 as the this object\n     *   addArgs.bind(1)(2, 3, 4) -> returns 9\n     *\n     ***/\n    'bind': function(context) {\n      // Optimized: no leaking arguments\n      var boundArgs = []; for(var $i = 1, $len = arguments.length; $i < $len; $i++) boundArgs.push(arguments[$i]);\n      var fn = this, bound;\n      assertCallable(this);\n      bound = function() {\n        // Optimized: no leaking arguments\n        var args = []; for(var $i = 0, $len = arguments.length; $i < $len; $i++) args.push(arguments[$i]);\n        return fn.apply(fn.prototype && this instanceof fn ? this : context, boundArgs.concat(args));\n      };\n      bound.prototype = this.prototype;\n      return bound;\n    }\n\n  });\n\n\n  /*** @namespace Date ***/\n\n  defineStaticPolyfill(sugarDate, {\n\n     /***\n     * @method now()\n     * @returns String\n     * @polyfill ES5\n     * @static\n     * @short Returns the current time as a Unix timestamp.\n     * @extra The number of milliseconds since January 1st, 1970 00:00:00 (UTC).\n     *\n     * @example\n     *\n     *   Date.now() -> ex. 1311938296231\n     *\n     ***/\n    'now': function() {\n      return new Date().getTime();\n    }\n\n  });\n\n  function hasISOSupport() {\n    var d = new Date(Date.UTC(2000, 0));\n    return !!d.toISOString && d.toISOString() === '2000-01-01T00:00:00.000Z';\n  }\n\n  defineInstancePolyfill(sugarDate, {\n\n     /***\n     * @method toISOString()\n     * @returns String\n     * @polyfill ES5\n     * @short Formats the string to ISO8601 format.\n     * @extra This will always format as UTC time.\n     *\n     * @example\n     *\n     *   Date.create().toISOString() -> ex. 2011-07-05 12:24:55.528Z\n     *\n     ***/\n    'toISOString': function() {\n      return padNumber(this.getUTCFullYear(), 4) + '-' +\n             padNumber(this.getUTCMonth() + 1, 2) + '-' +\n             padNumber(this.getUTCDate(), 2) + 'T' +\n             padNumber(this.getUTCHours(), 2) + ':' +\n             padNumber(this.getUTCMinutes(), 2) + ':' +\n             padNumber(this.getUTCSeconds(), 2) + '.' +\n             padNumber(this.getUTCMilliseconds(), 3) + 'Z';\n    },\n\n     /***\n     * @method toJSON([key])\n     * @returns String\n     * @polyfill ES5\n     * @short Returns a JSON representation of the date.\n     * @extra This is effectively an alias for `toISOString`. Will always return\n     *        the date in UTC time. [key] is ignored.\n     *\n     * @example\n     *\n     *   Date.create().toJSON() -> ex. 2011-07-05 12:24:55.528Z\n     *\n     ***/\n    'toJSON': function(key) {\n      // Force compiler to respect argument length.\n      var argLen = arguments.length;\n      return this.toISOString(key);\n    }\n\n  }, !hasISOSupport());\n\n}).call(this);"],"mappings":"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GAAGkC,oBAAoB,CAACH,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAC;QACjDE,aAAa,CAAC9C,cAAc,EAAEW,IAAI,CAACwB,OAAO,EAAEE,QAAQ,EAAEI,IAAI,EAAE9B,IAAI,CAACoC,IAAI,CAAC;QACtE,OAAO/C,cAAc;MACvB,CAAC,CAAC;IACJ;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIwC,uBAAuB,CAAC,cAAc,EAAE7D,MAAM,CAAC;;IAE/C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI6D,uBAAuB,CAAC,gBAAgB,EAAE5D,QAAQ,CAAC;;IAEnD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI4D,uBAAuB,CAAC,yBAAyB,EAAE5D,QAAQ,GAAGD,MAAM,CAAC;;IAGrE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI6D,uBAAuB,CAAC,2BAA2B,EAAE7D,MAAM,EAAE,IAAI,CAAC;;IAElE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI6D,uBAAuB,CAAC,6BAA6B,EAAE5D,QAAQ,EAAE,IAAI,CAAC;;IAEtE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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"},"metadata":{},"sourceType":"script","externalDependencies":[]}