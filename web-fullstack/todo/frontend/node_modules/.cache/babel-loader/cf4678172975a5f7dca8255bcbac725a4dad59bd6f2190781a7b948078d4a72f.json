{"ast":null,"code":"'use strict';\n\nvar LOCALE_ARRAY_FIELDS = require('../var/LOCALE_ARRAY_FIELDS'),\n  ISODefaults = require('../var/ISODefaults'),\n  CoreParsingTokens = require('../var/CoreParsingTokens'),\n  CoreParsingFormats = require('../var/CoreParsingFormats'),\n  LocalizedParsingTokens = require('../var/LocalizedParsingTokens'),\n  map = require('../../common/internal/map'),\n  filter = require('../../common/internal/filter'),\n  forEach = require('../../common/internal/forEach'),\n  isDefined = require('../../common/internal/isDefined'),\n  commaSplit = require('../../common/internal/commaSplit'),\n  classChecks = require('../../common/var/classChecks'),\n  mathAliases = require('../../common/var/mathAliases'),\n  isUndefined = require('../../common/internal/isUndefined'),\n  simpleMerge = require('../../common/internal/simpleMerge'),\n  getOrdinalSuffix = require('../../common/internal/getOrdinalSuffix'),\n  getArrayWithOffset = require('./getArrayWithOffset'),\n  getRegNonCapturing = require('./getRegNonCapturing'),\n  coreUtilityAliases = require('../../common/var/coreUtilityAliases'),\n  iterateOverDateUnits = require('./iterateOverDateUnits'),\n  arrayToRegAlternates = require('./arrayToRegAlternates'),\n  fullwidthNumberHelpers = require('../../common/var/fullwidthNumberHelpers'),\n  getAdjustedUnitForNumber = require('./getAdjustedUnitForNumber'),\n  getParsingTokenWithSuffix = require('./getParsingTokenWithSuffix');\nvar hasOwn = coreUtilityAliases.hasOwn,\n  getOwn = coreUtilityAliases.getOwn,\n  forEachProperty = coreUtilityAliases.forEachProperty,\n  fullWidthNumberMap = fullwidthNumberHelpers.fullWidthNumberMap,\n  fullWidthNumbers = fullwidthNumberHelpers.fullWidthNumbers,\n  pow = mathAliases.pow,\n  max = mathAliases.max,\n  ISO_FIRST_DAY_OF_WEEK = ISODefaults.ISO_FIRST_DAY_OF_WEEK,\n  ISO_FIRST_DAY_OF_WEEK_YEAR = ISODefaults.ISO_FIRST_DAY_OF_WEEK_YEAR,\n  isString = classChecks.isString,\n  isFunction = classChecks.isFunction;\nfunction getNewLocale(def) {\n  function Locale(def) {\n    this.init(def);\n  }\n  Locale.prototype = {\n    getMonthName: function (n, alternate) {\n      if (this.monthSuffix) {\n        return n + 1 + this.monthSuffix;\n      }\n      return getArrayWithOffset(this.months, n, alternate, 12);\n    },\n    getWeekdayName: function (n, alternate) {\n      return getArrayWithOffset(this.weekdays, n, alternate, 7);\n    },\n    // TODO: rename to parse in next major version\n    parseValue: function (str, param) {\n      var map = this[param + 'Map'];\n      if (hasOwn(map, str)) {\n        return map[str];\n      }\n      return this.parseNumber(str, param);\n    },\n    // TODO: analyze performance of parsing first vs checking\n    // numeralMap first.\n    parseNumber: function (str, param) {\n      var val;\n\n      // Simple numerals such as \"one\" are mapped directly in\n      // the numeral map so catch up front if there is a match.\n      if (hasOwn(this.numeralMap, str)) {\n        val = this.numeralMap[str];\n      }\n\n      // TODO: perf test isNaN vs other methods\n      if (isNaN(val)) {\n        val = this.parseRegularNumerals(str);\n      }\n      if (isNaN(val)) {\n        val = this.parseIrregularNumerals(str);\n      }\n      if (param === 'month') {\n        // Months are the only numeric date field\n        // whose value is not the same as its number.\n        val -= 1;\n      }\n      return val;\n    },\n    // TODO: perf test returning up front if no regular decimals exist\n    parseRegularNumerals: function (str) {\n      // Allow decimals as commas and the minus-sign as per ISO-8601.\n      str = str.replace(/^âˆ’/, '-').replace(/,/, '.');\n\n      // The unary plus operator here shows better performance and handles\n      // every format that parseFloat does with the exception of trailing\n      // characters, which are guaranteed not to be in our string at this point.\n      return +str;\n    },\n    parseIrregularNumerals: function (str) {\n      var place = 1,\n        num = 0,\n        lastWasPlace,\n        isPlace,\n        numeral,\n        digit,\n        arr;\n\n      // Note that \"numerals\" that need to be converted through this method are\n      // all considered to be single characters in order to handle CJK. This\n      // method is by no means unique to CJK, but the complexity of handling\n      // inflections in non-CJK languages adds too much overhead for not enough\n      // value, so avoiding for now.\n      arr = str.split('');\n      for (var i = arr.length - 1; numeral = arr[i]; i--) {\n        digit = getOwn(this.numeralMap, numeral);\n        if (isUndefined(digit)) {\n          digit = getOwn(fullWidthNumberMap, numeral) || 0;\n        }\n        isPlace = digit > 0 && digit % 10 === 0;\n        if (isPlace) {\n          if (lastWasPlace) {\n            num += place;\n          }\n          if (i) {\n            place = digit;\n          } else {\n            num += digit;\n          }\n        } else {\n          num += digit * place;\n          place *= 10;\n        }\n        lastWasPlace = isPlace;\n      }\n      return num;\n    },\n    getOrdinal: function (n) {\n      var suffix = this.ordinalSuffix;\n      return suffix || getOrdinalSuffix(n);\n    },\n    getRelativeFormat: function (adu, type) {\n      return this.convertAdjustedToFormat(adu, type);\n    },\n    getDuration: function (ms) {\n      return this.convertAdjustedToFormat(getAdjustedUnitForNumber(max(0, ms)), 'duration');\n    },\n    getFirstDayOfWeek: function () {\n      var val = this.firstDayOfWeek;\n      return isDefined(val) ? val : ISO_FIRST_DAY_OF_WEEK;\n    },\n    getFirstDayOfWeekYear: function () {\n      return this.firstDayOfWeekYear || ISO_FIRST_DAY_OF_WEEK_YEAR;\n    },\n    convertAdjustedToFormat: function (adu, type) {\n      var sign,\n        unit,\n        mult,\n        num = adu[0],\n        u = adu[1],\n        ms = adu[2],\n        format = this[type] || this.relative;\n      if (isFunction(format)) {\n        return format.call(this, num, u, ms, type);\n      }\n      mult = !this.plural || num === 1 ? 0 : 1;\n      unit = this.units[mult * 8 + u] || this.units[u];\n      sign = this[ms > 0 ? 'fromNow' : 'ago'];\n      return format.replace(/\\{(.*?)\\}/g, function (full, match) {\n        switch (match) {\n          case 'num':\n            return num;\n          case 'unit':\n            return unit;\n          case 'sign':\n            return sign;\n        }\n      });\n    },\n    cacheFormat: function (dif, i) {\n      this.compiledFormats.splice(i, 1);\n      this.compiledFormats.unshift(dif);\n    },\n    addFormat: function (format) {\n      var loc = this,\n        src,\n        to;\n      function getTokenSrc(token) {\n        var suffix,\n          src,\n          tmp,\n          opt = token.match(/\\?$/),\n          nc = token.match(/^(\\d+)\\??$/),\n          slice = token.match(/(\\d)(?:-(\\d))?/),\n          param = token.replace(/[^a-z]+$/i, '');\n\n        // Allowing alias tokens such as {time}\n        if (tmp = getOwn(loc.parsingAliases, param)) {\n          src = formatToSrc(tmp);\n          if (opt) {\n            src = getRegNonCapturing(src, true);\n          }\n          return src;\n        }\n        if (nc) {\n          src = loc.tokens[nc[1]];\n        } else if (tmp = getOwn(CoreParsingTokens, param)) {\n          src = tmp.src;\n          param = tmp.param || param;\n        } else {\n          tmp = getOwn(loc.parsingTokens, param) || getOwn(loc, param);\n\n          // Both the \"months\" array and the \"month\" parsing token can be accessed\n          // by either {month} or {months}, falling back as necessary, however\n          // regardless of whether or not a fallback occurs, the final field to\n          // be passed to addRawFormat must be normalized as singular.\n          param = param.replace(/s$/, '');\n          if (!tmp) {\n            tmp = getOwn(loc.parsingTokens, param) || getOwn(loc, param + 's');\n          }\n          if (isString(tmp)) {\n            src = tmp;\n            suffix = loc[param + 'Suffix'];\n          } else {\n            // This is a hack to temporarily disallow parsing of single character\n            // weekdays until the format can be changed to allow for this.\n            if (param === 'weekday' && loc.code === 'ko') {\n              tmp = filter(tmp, function (str) {\n                return str.length > 1;\n              });\n            }\n            if (slice) {\n              tmp = filter(tmp, function (m, i) {\n                var mod = i % (loc.units ? 8 : tmp.length);\n                return mod >= slice[1] && mod <= (slice[2] || slice[1]);\n              });\n            }\n            src = arrayToRegAlternates(tmp);\n          }\n        }\n        if (!src) {\n          return '';\n        }\n        if (nc) {\n          // Non-capturing tokens like {0}\n          src = getRegNonCapturing(src);\n        } else {\n          // Capturing group and add to parsed tokens\n          to.push(param);\n          src = '(' + src + ')';\n        }\n        if (suffix) {\n          // Date/time suffixes such as those in CJK\n          src = getParsingTokenWithSuffix(param, src, suffix);\n        }\n        if (opt) {\n          src += '?';\n        }\n        return src;\n      }\n      function formatToSrc(str) {\n        // Make spaces optional\n        str = str.replace(/ /g, ' ?');\n        str = str.replace(/\\{([^,]+?)\\}/g, function (match, token) {\n          var tokens = token.split('|');\n          if (tokens.length > 1) {\n            return getRegNonCapturing(map(tokens, getTokenSrc).join('|'));\n          } else {\n            return getTokenSrc(token);\n          }\n        });\n        return str;\n      }\n      function parseInputFormat() {\n        to = [];\n        src = formatToSrc(format);\n      }\n      parseInputFormat();\n      loc.addRawFormat(src, to);\n    },\n    addRawFormat: function (format, to) {\n      this.compiledFormats.unshift({\n        reg: RegExp('^ *' + format + ' *$', 'i'),\n        to: to\n      });\n    },\n    init: function (def) {\n      var loc = this;\n\n      // -- Initialization helpers\n\n      function initFormats() {\n        loc.compiledFormats = [];\n        loc.parsingAliases = {};\n        loc.parsingTokens = {};\n      }\n      function initDefinition() {\n        simpleMerge(loc, def);\n      }\n      function initArrayFields() {\n        forEach(LOCALE_ARRAY_FIELDS, function (name) {\n          var val = loc[name];\n          if (isString(val)) {\n            loc[name] = commaSplit(val);\n          } else if (!val) {\n            loc[name] = [];\n          }\n        });\n      }\n\n      // -- Value array build helpers\n\n      function buildValueArray(name, mod, map, fn) {\n        var field = name,\n          all = [],\n          setMap;\n        if (!loc[field]) {\n          field += 's';\n        }\n        if (!map) {\n          map = {};\n          setMap = true;\n        }\n        forAllAlternates(field, function (alt, j, i) {\n          var idx = j * mod + i,\n            val;\n          val = fn ? fn(i) : i;\n          map[alt] = val;\n          map[alt.toLowerCase()] = val;\n          all[idx] = alt;\n        });\n        loc[field] = all;\n        if (setMap) {\n          loc[name + 'Map'] = map;\n        }\n      }\n      function forAllAlternates(field, fn) {\n        forEach(loc[field], function (str, i) {\n          forEachAlternate(str, function (alt, j) {\n            fn(alt, j, i);\n          });\n        });\n      }\n      function forEachAlternate(str, fn) {\n        var arr = map(str.split('+'), function (split) {\n          return split.replace(/(.+):(.+)$/, function (full, base, suffixes) {\n            return map(suffixes.split('|'), function (suffix) {\n              return base + suffix;\n            }).join('|');\n          });\n        }).join('|');\n        forEach(arr.split('|'), fn);\n      }\n      function buildNumerals() {\n        var map = {};\n        buildValueArray('numeral', 10, map);\n        buildValueArray('article', 1, map, function () {\n          return 1;\n        });\n        buildValueArray('placeholder', 4, map, function (n) {\n          return pow(10, n + 1);\n        });\n        loc.numeralMap = map;\n      }\n      function buildTimeFormats() {\n        loc.parsingAliases['time'] = getTimeFormat();\n        loc.parsingAliases['tzOffset'] = getTZOffsetFormat();\n      }\n      function getTimeFormat(standalone) {\n        var src, sep;\n        sep = getTimeSeparatorSrc(standalone);\n        if (loc.ampmFront) {\n          // \"ampmFront\" exists mostly for CJK locales, which also presume that\n          // time suffixes exist, allowing this to be a simpler regex.\n          src = '{ampm?} {hour} (?:{minute} (?::?{second})?)?';\n        } else if (loc.ampm.length) {\n          src = '{hour}(?:' + sep + '{minute?}(?:' + sep + '{second?})? {ampm?}| {ampm})';\n        } else {\n          src = '{hour}(?:' + sep + '{minute?}(?:' + sep + '{second?})?)';\n        }\n        return src;\n      }\n      function getTimeSeparatorSrc() {\n        if (loc.timeSeparator) {\n          return '[:' + loc.timeSeparator + ']';\n        } else {\n          return ':';\n        }\n      }\n      function getTZOffsetFormat() {\n        return '(?:{Z}|{GMT?}(?:{tzHour}(?::?{tzMinute}(?: \\\\([\\\\w\\\\s]+\\\\))?)?)?)?';\n      }\n      function buildParsingTokens() {\n        forEachProperty(LocalizedParsingTokens, function (token, name) {\n          var src = token.base ? getCoreTokensForBase(token.base) : token.src,\n            arr;\n          if (token.requiresNumerals || loc.numeralUnits) {\n            src += getNumeralSrc();\n          }\n          arr = loc[name + 's'];\n          if (arr && arr.length) {\n            src += '|' + arrayToRegAlternates(arr);\n          }\n          loc.parsingTokens[name] = src;\n        });\n      }\n      function getCoreTokensForBase(base) {\n        return map(base.split('|'), function (key) {\n          return CoreParsingTokens[key].src;\n        }).join('|');\n      }\n      function getNumeralSrc() {\n        var all,\n          src = '';\n        all = loc.numerals.concat(loc.placeholders).concat(loc.articles);\n        if (loc.allowsFullWidth) {\n          all = all.concat(fullWidthNumbers.split(''));\n        }\n        if (all.length) {\n          src = '|(?:' + arrayToRegAlternates(all) + ')+';\n        }\n        return src;\n      }\n      function buildTimeSuffixes() {\n        iterateOverDateUnits(function (unit, i) {\n          var token = loc.timeSuffixes[i];\n          if (token) {\n            loc[(unit.alias || unit.name) + 'Suffix'] = token;\n          }\n        });\n      }\n      function buildModifiers() {\n        forEach(loc.modifiers, function (modifier) {\n          var name = modifier.name,\n            mapKey = name + 'Map',\n            map;\n          map = loc[mapKey] || {};\n          forEachAlternate(modifier.src, function (alt, j) {\n            var token = getOwn(loc.parsingTokens, name),\n              val = modifier.value;\n            map[alt] = val;\n            loc.parsingTokens[name] = token ? token + '|' + alt : alt;\n            if (modifier.name === 'sign' && j === 0) {\n              // Hooking in here to set the first \"fromNow\" or \"ago\" modifier\n              // directly on the locale, so that it can be reused in the\n              // relative format.\n              loc[val === 1 ? 'fromNow' : 'ago'] = alt;\n            }\n          });\n          loc[mapKey] = map;\n        });\n      }\n\n      // -- Format adding helpers\n\n      function addCoreFormats() {\n        forEach(CoreParsingFormats, function (df) {\n          var src = df.src;\n          if (df.localeCheck && !df.localeCheck(loc)) {\n            return;\n          }\n          if (df.mdy && loc.mdy) {\n            // Use the mm/dd/yyyy variant if it\n            // exists and the locale requires it\n            src = df.mdy;\n          }\n          if (df.time) {\n            // Core formats that allow time require the time\n            // reg on both sides, so add both versions here.\n            loc.addFormat(getFormatWithTime(src, true));\n            loc.addFormat(getFormatWithTime(src));\n          } else {\n            loc.addFormat(src);\n          }\n        });\n        loc.addFormat('{time}');\n      }\n      function addLocaleFormats() {\n        addFormatSet('parse');\n        addFormatSet('timeParse', true);\n        addFormatSet('timeFrontParse', true, true);\n      }\n      function addFormatSet(field, allowTime, timeFront) {\n        forEach(loc[field], function (format) {\n          if (allowTime) {\n            format = getFormatWithTime(format, timeFront);\n          }\n          loc.addFormat(format);\n        });\n      }\n      function getFormatWithTime(baseFormat, timeBefore) {\n        if (timeBefore) {\n          return getTimeBefore() + baseFormat;\n        }\n        return baseFormat + getTimeAfter();\n      }\n      function getTimeBefore() {\n        return getRegNonCapturing('{time}[,\\\\s\\\\u3000]', true);\n      }\n      function getTimeAfter() {\n        var markers = ',?[\\\\s\\\\u3000]',\n          localized;\n        localized = arrayToRegAlternates(loc.timeMarkers);\n        if (localized) {\n          markers += '| (?:' + localized + ') ';\n        }\n        markers = getRegNonCapturing(markers, loc.timeMarkerOptional);\n        return getRegNonCapturing(markers + '{time}{tzOffset}', true);\n      }\n      initFormats();\n      initDefinition();\n      initArrayFields();\n      buildValueArray('month', 12);\n      buildValueArray('weekday', 7);\n      buildValueArray('unit', 8);\n      buildValueArray('ampm', 2);\n      buildNumerals();\n      buildTimeFormats();\n      buildParsingTokens();\n      buildTimeSuffixes();\n      buildModifiers();\n\n      // The order of these formats is important. Order is reversed so formats\n      // that are initialized later will take precedence. Generally, this means\n      // that more specific formats should come later.\n      addCoreFormats();\n      addLocaleFormats();\n    }\n  };\n  return new Locale(def);\n}\nmodule.exports = getNewLocale;","map":{"version":3,"names":["LOCALE_ARRAY_FIELDS","require","ISODefaults","CoreParsingTokens","CoreParsingFormats","LocalizedParsingTokens","map","filter","forEach","isDefined","commaSplit","classChecks","mathAliases","isUndefined","simpleMerge","getOrdinalSuffix","getArrayWithOffset","getRegNonCapturing","coreUtilityAliases","iterateOverDateUnits","arrayToRegAlternates","fullwidthNumberHelpers","getAdjustedUnitForNumber","getParsingTokenWithSuffix","hasOwn","getOwn","forEachProperty","fullWidthNumberMap","fullWidthNumbers","pow","max","ISO_FIRST_DAY_OF_WEEK","ISO_FIRST_DAY_OF_WEEK_YEAR","isString","isFunction","getNewLocale","def","Locale","init","prototype","getMonthName","n","alternate","monthSuffix","months","getWeekdayName","weekdays","parseValue","str","param","parseNumber","val","numeralMap","isNaN","parseRegularNumerals","parseIrregularNumerals","replace","place","num","lastWasPlace","isPlace","numeral","digit","arr","split","i","length","getOrdinal","suffix","ordinalSuffix","getRelativeFormat","adu","type","convertAdjustedToFormat","getDuration","ms","getFirstDayOfWeek","firstDayOfWeek","getFirstDayOfWeekYear","firstDayOfWeekYear","sign","unit","mult","u","format","relative","call","plural","units","full","match","cacheFormat","dif","compiledFormats","splice","unshift","addFormat","loc","src","to","getTokenSrc","token","tmp","opt","nc","slice","parsingAliases","formatToSrc","tokens","parsingTokens","code","m","mod","push","join","parseInputFormat","addRawFormat","reg","RegExp","initFormats","initDefinition","initArrayFields","name","buildValueArray","fn","field","all","setMap","forAllAlternates","alt","j","idx","toLowerCase","forEachAlternate","base","suffixes","buildNumerals","buildTimeFormats","getTimeFormat","getTZOffsetFormat","standalone","sep","getTimeSeparatorSrc","ampmFront","ampm","timeSeparator","buildParsingTokens","getCoreTokensForBase","requiresNumerals","numeralUnits","getNumeralSrc","key","numerals","concat","placeholders","articles","allowsFullWidth","buildTimeSuffixes","timeSuffixes","alias","buildModifiers","modifiers","modifier","mapKey","value","addCoreFormats","df","localeCheck","mdy","time","getFormatWithTime","addLocaleFormats","addFormatSet","allowTime","timeFront","baseFormat","timeBefore","getTimeBefore","getTimeAfter","markers","localized","timeMarkers","timeMarkerOptional","module","exports"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/todo/node_modules/sugar-date/date/internal/getNewLocale.js"],"sourcesContent":["'use strict';\n\nvar LOCALE_ARRAY_FIELDS = require('../var/LOCALE_ARRAY_FIELDS'),\n    ISODefaults = require('../var/ISODefaults'),\n    CoreParsingTokens = require('../var/CoreParsingTokens'),\n    CoreParsingFormats = require('../var/CoreParsingFormats'),\n    LocalizedParsingTokens = require('../var/LocalizedParsingTokens'),\n    map = require('../../common/internal/map'),\n    filter = require('../../common/internal/filter'),\n    forEach = require('../../common/internal/forEach'),\n    isDefined = require('../../common/internal/isDefined'),\n    commaSplit = require('../../common/internal/commaSplit'),\n    classChecks = require('../../common/var/classChecks'),\n    mathAliases = require('../../common/var/mathAliases'),\n    isUndefined = require('../../common/internal/isUndefined'),\n    simpleMerge = require('../../common/internal/simpleMerge'),\n    getOrdinalSuffix = require('../../common/internal/getOrdinalSuffix'),\n    getArrayWithOffset = require('./getArrayWithOffset'),\n    getRegNonCapturing = require('./getRegNonCapturing'),\n    coreUtilityAliases = require('../../common/var/coreUtilityAliases'),\n    iterateOverDateUnits = require('./iterateOverDateUnits'),\n    arrayToRegAlternates = require('./arrayToRegAlternates'),\n    fullwidthNumberHelpers = require('../../common/var/fullwidthNumberHelpers'),\n    getAdjustedUnitForNumber = require('./getAdjustedUnitForNumber'),\n    getParsingTokenWithSuffix = require('./getParsingTokenWithSuffix');\n\nvar hasOwn = coreUtilityAliases.hasOwn,\n    getOwn = coreUtilityAliases.getOwn,\n    forEachProperty = coreUtilityAliases.forEachProperty,\n    fullWidthNumberMap = fullwidthNumberHelpers.fullWidthNumberMap,\n    fullWidthNumbers = fullwidthNumberHelpers.fullWidthNumbers,\n    pow = mathAliases.pow,\n    max = mathAliases.max,\n    ISO_FIRST_DAY_OF_WEEK = ISODefaults.ISO_FIRST_DAY_OF_WEEK,\n    ISO_FIRST_DAY_OF_WEEK_YEAR = ISODefaults.ISO_FIRST_DAY_OF_WEEK_YEAR,\n    isString = classChecks.isString,\n    isFunction = classChecks.isFunction;\n\nfunction getNewLocale(def) {\n\n  function Locale(def) {\n    this.init(def);\n  }\n\n  Locale.prototype = {\n\n    getMonthName: function(n, alternate) {\n      if (this.monthSuffix) {\n        return (n + 1) + this.monthSuffix;\n      }\n      return getArrayWithOffset(this.months, n, alternate, 12);\n    },\n\n    getWeekdayName: function(n, alternate) {\n      return getArrayWithOffset(this.weekdays, n, alternate, 7);\n    },\n\n    // TODO: rename to parse in next major version\n    parseValue: function(str, param) {\n      var map = this[param + 'Map'];\n      if (hasOwn(map, str)) {\n        return map[str];\n      }\n      return this.parseNumber(str, param);\n    },\n\n    // TODO: analyze performance of parsing first vs checking\n    // numeralMap first.\n    parseNumber: function(str, param) {\n      var val;\n\n      // Simple numerals such as \"one\" are mapped directly in\n      // the numeral map so catch up front if there is a match.\n      if (hasOwn(this.numeralMap, str)) {\n        val = this.numeralMap[str];\n      }\n\n      // TODO: perf test isNaN vs other methods\n      if (isNaN(val)) {\n        val = this.parseRegularNumerals(str);\n      }\n\n      if (isNaN(val)) {\n        val = this.parseIrregularNumerals(str);\n      }\n\n      if (param === 'month') {\n        // Months are the only numeric date field\n        // whose value is not the same as its number.\n        val -= 1;\n      }\n\n      return val;\n    },\n\n    // TODO: perf test returning up front if no regular decimals exist\n    parseRegularNumerals: function(str) {\n      // Allow decimals as commas and the minus-sign as per ISO-8601.\n      str = str.replace(/^âˆ’/, '-').replace(/,/, '.');\n\n      // The unary plus operator here shows better performance and handles\n      // every format that parseFloat does with the exception of trailing\n      // characters, which are guaranteed not to be in our string at this point.\n      return +str;\n    },\n\n    parseIrregularNumerals: function(str) {\n      var place = 1, num = 0, lastWasPlace, isPlace, numeral, digit, arr;\n\n      // Note that \"numerals\" that need to be converted through this method are\n      // all considered to be single characters in order to handle CJK. This\n      // method is by no means unique to CJK, but the complexity of handling\n      // inflections in non-CJK languages adds too much overhead for not enough\n      // value, so avoiding for now.\n      arr = str.split('');\n      for (var i = arr.length - 1; numeral = arr[i]; i--) {\n        digit = getOwn(this.numeralMap, numeral);\n        if (isUndefined(digit)) {\n          digit = getOwn(fullWidthNumberMap, numeral) || 0;\n        }\n        isPlace = digit > 0 && digit % 10 === 0;\n        if (isPlace) {\n          if (lastWasPlace) {\n            num += place;\n          }\n          if (i) {\n            place = digit;\n          } else {\n            num += digit;\n          }\n        } else {\n          num += digit * place;\n          place *= 10;\n        }\n        lastWasPlace = isPlace;\n      }\n      return num;\n    },\n\n    getOrdinal: function(n) {\n      var suffix = this.ordinalSuffix;\n      return suffix || getOrdinalSuffix(n);\n    },\n\n    getRelativeFormat: function(adu, type) {\n      return this.convertAdjustedToFormat(adu, type);\n    },\n\n    getDuration: function(ms) {\n      return this.convertAdjustedToFormat(getAdjustedUnitForNumber(max(0, ms)), 'duration');\n    },\n\n    getFirstDayOfWeek: function() {\n      var val = this.firstDayOfWeek;\n      return isDefined(val) ? val : ISO_FIRST_DAY_OF_WEEK;\n    },\n\n    getFirstDayOfWeekYear: function() {\n      return this.firstDayOfWeekYear || ISO_FIRST_DAY_OF_WEEK_YEAR;\n    },\n\n    convertAdjustedToFormat: function(adu, type) {\n      var sign, unit, mult,\n          num    = adu[0],\n          u      = adu[1],\n          ms     = adu[2],\n          format = this[type] || this.relative;\n      if (isFunction(format)) {\n        return format.call(this, num, u, ms, type);\n      }\n      mult = !this.plural || num === 1 ? 0 : 1;\n      unit = this.units[mult * 8 + u] || this.units[u];\n      sign = this[ms > 0 ? 'fromNow' : 'ago'];\n      return format.replace(/\\{(.*?)\\}/g, function(full, match) {\n        switch(match) {\n          case 'num': return num;\n          case 'unit': return unit;\n          case 'sign': return sign;\n        }\n      });\n    },\n\n    cacheFormat: function(dif, i) {\n      this.compiledFormats.splice(i, 1);\n      this.compiledFormats.unshift(dif);\n    },\n\n    addFormat: function(format) {\n      var loc = this, src, to;\n\n      function getTokenSrc(token) {\n        var suffix, src, tmp,\n            opt   = token.match(/\\?$/),\n            nc    = token.match(/^(\\d+)\\??$/),\n            slice = token.match(/(\\d)(?:-(\\d))?/),\n            param = token.replace(/[^a-z]+$/i, '');\n\n        // Allowing alias tokens such as {time}\n        if (tmp = getOwn(loc.parsingAliases, param)) {\n          src = formatToSrc(tmp);\n          if (opt) {\n            src = getRegNonCapturing(src, true);\n          }\n          return src;\n        }\n\n        if (nc) {\n          src = loc.tokens[nc[1]];\n        } else if (tmp = getOwn(CoreParsingTokens, param)) {\n          src = tmp.src;\n          param = tmp.param || param;\n        } else {\n          tmp = getOwn(loc.parsingTokens, param) || getOwn(loc, param);\n\n          // Both the \"months\" array and the \"month\" parsing token can be accessed\n          // by either {month} or {months}, falling back as necessary, however\n          // regardless of whether or not a fallback occurs, the final field to\n          // be passed to addRawFormat must be normalized as singular.\n          param = param.replace(/s$/, '');\n\n          if (!tmp) {\n            tmp = getOwn(loc.parsingTokens, param) || getOwn(loc, param + 's');\n          }\n\n          if (isString(tmp)) {\n            src = tmp;\n            suffix = loc[param + 'Suffix'];\n          } else {\n\n            // This is a hack to temporarily disallow parsing of single character\n            // weekdays until the format can be changed to allow for this.\n            if (param === 'weekday' && loc.code === 'ko') {\n              tmp = filter(tmp, function(str) {\n                return str.length > 1;\n              });\n            }\n\n            if (slice) {\n              tmp = filter(tmp, function(m, i) {\n                var mod = i % (loc.units ? 8 : tmp.length);\n                return mod >= slice[1] && mod <= (slice[2] || slice[1]);\n              });\n            }\n            src = arrayToRegAlternates(tmp);\n          }\n        }\n        if (!src) {\n          return '';\n        }\n        if (nc) {\n          // Non-capturing tokens like {0}\n          src = getRegNonCapturing(src);\n        } else {\n          // Capturing group and add to parsed tokens\n          to.push(param);\n          src = '(' + src + ')';\n        }\n        if (suffix) {\n          // Date/time suffixes such as those in CJK\n          src = getParsingTokenWithSuffix(param, src, suffix);\n        }\n        if (opt) {\n          src += '?';\n        }\n        return src;\n      }\n\n      function formatToSrc(str) {\n\n        // Make spaces optional\n        str = str.replace(/ /g, ' ?');\n\n        str = str.replace(/\\{([^,]+?)\\}/g, function(match, token) {\n          var tokens = token.split('|');\n          if (tokens.length > 1) {\n            return getRegNonCapturing(map(tokens, getTokenSrc).join('|'));\n          } else {\n            return getTokenSrc(token);\n          }\n        });\n\n        return str;\n      }\n\n      function parseInputFormat() {\n        to = [];\n        src = formatToSrc(format);\n      }\n\n      parseInputFormat();\n      loc.addRawFormat(src, to);\n    },\n\n    addRawFormat: function(format, to) {\n      this.compiledFormats.unshift({\n        reg: RegExp('^ *' + format + ' *$', 'i'),\n        to: to\n      });\n    },\n\n    init: function(def) {\n      var loc = this;\n\n      // -- Initialization helpers\n\n      function initFormats() {\n        loc.compiledFormats = [];\n        loc.parsingAliases = {};\n        loc.parsingTokens = {};\n      }\n\n      function initDefinition() {\n        simpleMerge(loc, def);\n      }\n\n      function initArrayFields() {\n        forEach(LOCALE_ARRAY_FIELDS, function(name) {\n          var val = loc[name];\n          if (isString(val)) {\n            loc[name] = commaSplit(val);\n          } else if (!val) {\n            loc[name] = [];\n          }\n        });\n      }\n\n      // -- Value array build helpers\n\n      function buildValueArray(name, mod, map, fn) {\n        var field = name, all = [], setMap;\n        if (!loc[field]) {\n          field += 's';\n        }\n        if (!map) {\n          map = {};\n          setMap = true;\n        }\n        forAllAlternates(field, function(alt, j, i) {\n          var idx = j * mod + i, val;\n          val = fn ? fn(i) : i;\n          map[alt] = val;\n          map[alt.toLowerCase()] = val;\n          all[idx] = alt;\n        });\n        loc[field] = all;\n        if (setMap) {\n          loc[name + 'Map'] = map;\n        }\n      }\n\n      function forAllAlternates(field, fn) {\n        forEach(loc[field], function(str, i) {\n          forEachAlternate(str, function(alt, j) {\n            fn(alt, j, i);\n          });\n        });\n      }\n\n      function forEachAlternate(str, fn) {\n        var arr = map(str.split('+'), function(split) {\n          return split.replace(/(.+):(.+)$/, function(full, base, suffixes) {\n            return map(suffixes.split('|'), function(suffix) {\n              return base + suffix;\n            }).join('|');\n          });\n        }).join('|');\n        forEach(arr.split('|'), fn);\n      }\n\n      function buildNumerals() {\n        var map = {};\n        buildValueArray('numeral', 10, map);\n        buildValueArray('article', 1, map, function() {\n          return 1;\n        });\n        buildValueArray('placeholder', 4, map, function(n) {\n          return pow(10, n + 1);\n        });\n        loc.numeralMap = map;\n      }\n\n      function buildTimeFormats() {\n        loc.parsingAliases['time'] = getTimeFormat();\n        loc.parsingAliases['tzOffset'] = getTZOffsetFormat();\n      }\n\n      function getTimeFormat(standalone) {\n        var src, sep;\n        sep = getTimeSeparatorSrc(standalone);\n        if (loc.ampmFront) {\n          // \"ampmFront\" exists mostly for CJK locales, which also presume that\n          // time suffixes exist, allowing this to be a simpler regex.\n          src = '{ampm?} {hour} (?:{minute} (?::?{second})?)?';\n        } else if(loc.ampm.length) {\n          src = '{hour}(?:'+sep+'{minute?}(?:'+sep+'{second?})? {ampm?}| {ampm})';\n        } else {\n          src = '{hour}(?:'+sep+'{minute?}(?:'+sep+'{second?})?)';\n        }\n        return src;\n      }\n\n      function getTimeSeparatorSrc() {\n        if (loc.timeSeparator) {\n          return '[:' + loc.timeSeparator + ']';\n        } else {\n          return ':';\n        }\n      }\n\n      function getTZOffsetFormat() {\n        return '(?:{Z}|{GMT?}(?:{tzHour}(?::?{tzMinute}(?: \\\\([\\\\w\\\\s]+\\\\))?)?)?)?';\n      }\n\n      function buildParsingTokens() {\n        forEachProperty(LocalizedParsingTokens, function(token, name) {\n          var src = token.base ? getCoreTokensForBase(token.base) : token.src, arr;\n          if (token.requiresNumerals || loc.numeralUnits) {\n            src += getNumeralSrc();\n          }\n          arr = loc[name + 's'];\n          if (arr && arr.length) {\n            src += '|' + arrayToRegAlternates(arr);\n          }\n          loc.parsingTokens[name] = src;\n        });\n      }\n\n      function getCoreTokensForBase(base) {\n        return map(base.split('|'), function(key) {\n          return CoreParsingTokens[key].src;\n        }).join('|');\n      }\n\n      function getNumeralSrc() {\n        var all, src = '';\n        all = loc.numerals.concat(loc.placeholders).concat(loc.articles);\n        if (loc.allowsFullWidth) {\n          all = all.concat(fullWidthNumbers.split(''));\n        }\n        if (all.length) {\n          src = '|(?:' + arrayToRegAlternates(all) + ')+';\n        }\n        return src;\n      }\n\n      function buildTimeSuffixes() {\n        iterateOverDateUnits(function(unit, i) {\n          var token = loc.timeSuffixes[i];\n          if (token) {\n            loc[(unit.alias || unit.name) + 'Suffix'] = token;\n          }\n        });\n      }\n\n      function buildModifiers() {\n        forEach(loc.modifiers, function(modifier) {\n          var name = modifier.name, mapKey = name + 'Map', map;\n          map = loc[mapKey] || {};\n          forEachAlternate(modifier.src, function(alt, j) {\n            var token = getOwn(loc.parsingTokens, name), val = modifier.value;\n            map[alt] = val;\n            loc.parsingTokens[name] = token ? token + '|' + alt : alt;\n            if (modifier.name === 'sign' && j === 0) {\n              // Hooking in here to set the first \"fromNow\" or \"ago\" modifier\n              // directly on the locale, so that it can be reused in the\n              // relative format.\n              loc[val === 1 ? 'fromNow' : 'ago'] = alt;\n            }\n          });\n          loc[mapKey] = map;\n        });\n      }\n\n      // -- Format adding helpers\n\n      function addCoreFormats() {\n        forEach(CoreParsingFormats, function(df) {\n          var src = df.src;\n          if (df.localeCheck && !df.localeCheck(loc)) {\n            return;\n          }\n          if (df.mdy && loc.mdy) {\n            // Use the mm/dd/yyyy variant if it\n            // exists and the locale requires it\n            src = df.mdy;\n          }\n          if (df.time) {\n            // Core formats that allow time require the time\n            // reg on both sides, so add both versions here.\n            loc.addFormat(getFormatWithTime(src, true));\n            loc.addFormat(getFormatWithTime(src));\n          } else {\n            loc.addFormat(src);\n          }\n        });\n        loc.addFormat('{time}');\n      }\n\n      function addLocaleFormats() {\n        addFormatSet('parse');\n        addFormatSet('timeParse', true);\n        addFormatSet('timeFrontParse', true, true);\n      }\n\n      function addFormatSet(field, allowTime, timeFront) {\n        forEach(loc[field], function(format) {\n          if (allowTime) {\n            format = getFormatWithTime(format, timeFront);\n          }\n          loc.addFormat(format);\n        });\n      }\n\n      function getFormatWithTime(baseFormat, timeBefore) {\n        if (timeBefore) {\n          return getTimeBefore() + baseFormat;\n        }\n        return baseFormat + getTimeAfter();\n      }\n\n      function getTimeBefore() {\n        return getRegNonCapturing('{time}[,\\\\s\\\\u3000]', true);\n      }\n\n      function getTimeAfter() {\n        var markers = ',?[\\\\s\\\\u3000]', localized;\n        localized = arrayToRegAlternates(loc.timeMarkers);\n        if (localized) {\n          markers += '| (?:' + localized + ') ';\n        }\n        markers = getRegNonCapturing(markers, loc.timeMarkerOptional);\n        return getRegNonCapturing(markers + '{time}{tzOffset}', true);\n      }\n\n      initFormats();\n      initDefinition();\n      initArrayFields();\n\n      buildValueArray('month', 12);\n      buildValueArray('weekday', 7);\n      buildValueArray('unit', 8);\n      buildValueArray('ampm', 2);\n\n      buildNumerals();\n      buildTimeFormats();\n      buildParsingTokens();\n      buildTimeSuffixes();\n      buildModifiers();\n\n      // The order of these formats is important. Order is reversed so formats\n      // that are initialized later will take precedence. Generally, this means\n      // that more specific formats should come later.\n      addCoreFormats();\n      addLocaleFormats();\n\n    }\n\n  };\n\n  return new Locale(def);\n}\n\nmodule.exports = getNewLocale;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}