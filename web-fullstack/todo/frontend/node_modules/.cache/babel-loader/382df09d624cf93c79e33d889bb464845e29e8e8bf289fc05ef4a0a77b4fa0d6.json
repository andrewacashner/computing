{"ast":null,"code":"'use strict';\n\nvar MINUTES = require('../var/MINUTES'),\n  ABBREVIATED_YEAR_REG = require('../var/ABBREVIATED_YEAR_REG'),\n  LocaleHelpers = require('../var/LocaleHelpers'),\n  DateUnitIndexes = require('../var/DateUnitIndexes'),\n  _utc = require('../../common/var/_utc'),\n  trunc = require('../../common/var/trunc'),\n  forEach = require('../../common/internal/forEach'),\n  tzOffset = require('./tzOffset'),\n  isDefined = require('../../common/internal/isDefined'),\n  resetTime = require('./resetTime'),\n  getNewDate = require('./getNewDate'),\n  updateDate = require('./updateDate'),\n  setWeekday = require('./setWeekday'),\n  simpleMerge = require('../../common/internal/simpleMerge'),\n  advanceDate = require('./advanceDate'),\n  isUndefined = require('../../common/internal/isUndefined'),\n  classChecks = require('../../common/var/classChecks'),\n  dateIsValid = require('./dateIsValid'),\n  simpleClone = require('../../common/internal/simpleClone'),\n  isObjectType = require('../../common/internal/isObjectType'),\n  moveToEndOfUnit = require('./moveToEndOfUnit'),\n  deleteDateParam = require('./deleteDateParam'),\n  coreUtilityAliases = require('../../common/var/coreUtilityAliases'),\n  moveToBeginningOfUnit = require('./moveToBeginningOfUnit'),\n  iterateOverDateParams = require('./iterateOverDateParams'),\n  getYearFromAbbreviation = require('./getYearFromAbbreviation'),\n  iterateOverHigherDateParams = require('./iterateOverHigherDateParams');\nvar isNumber = classChecks.isNumber,\n  isString = classChecks.isString,\n  isDate = classChecks.isDate,\n  getOwn = coreUtilityAliases.getOwn,\n  English = LocaleHelpers.English,\n  localeManager = LocaleHelpers.localeManager,\n  DAY_INDEX = DateUnitIndexes.DAY_INDEX,\n  WEEK_INDEX = DateUnitIndexes.WEEK_INDEX,\n  MONTH_INDEX = DateUnitIndexes.MONTH_INDEX,\n  YEAR_INDEX = DateUnitIndexes.YEAR_INDEX;\nfunction getExtendedDate(contextDate, d, opt, forceClone) {\n  // Locals\n  var date, set, loc, afterCallbacks, relative, weekdayDir;\n\n  // Options\n  var optPrefer, optLocale, optFromUTC, optSetUTC, optParams, optClone;\n  afterCallbacks = [];\n  setupOptions(opt);\n  function setupOptions(opt) {\n    opt = isString(opt) ? {\n      locale: opt\n    } : opt || {};\n    optPrefer = +!!getOwn(opt, 'future') - +!!getOwn(opt, 'past');\n    optLocale = getOwn(opt, 'locale');\n    optFromUTC = getOwn(opt, 'fromUTC');\n    optSetUTC = getOwn(opt, 'setUTC');\n    optParams = getOwn(opt, 'params');\n    optClone = getOwn(opt, 'clone');\n  }\n  function parseFormatValues(match, dif) {\n    var set = optParams || {};\n    forEach(dif.to, function (param, i) {\n      var str = match[i + 1],\n        val;\n      if (!str) return;\n      val = parseIrregular(str, param);\n      if (isUndefined(val)) {\n        val = loc.parseValue(str, param);\n      }\n      set[param] = val;\n    });\n    return set;\n  }\n  function parseIrregular(str, param) {\n    if (param === 'utc') {\n      return 1;\n    } else if (param === 'year') {\n      var match = str.match(ABBREVIATED_YEAR_REG);\n      if (match) {\n        return getYearFromAbbreviation(match[1], date, optPrefer);\n      }\n    }\n  }\n\n  // Force the UTC flags to be true if the source date\n  // date is UTC, as they will be overwritten later.\n  function cloneDateByFlag(d, clone) {\n    if (_utc(d) && !isDefined(optFromUTC)) {\n      optFromUTC = true;\n    }\n    if (_utc(d) && !isDefined(optSetUTC)) {\n      optSetUTC = true;\n    }\n    if (clone) {\n      d = new Date(d.getTime());\n    }\n    return d;\n  }\n  function afterDateSet(fn) {\n    afterCallbacks.push(fn);\n  }\n  function fireCallbacks() {\n    forEach(afterCallbacks, function (fn) {\n      fn.call();\n    });\n  }\n  function parseStringDate(str) {\n    str = str.toLowerCase();\n\n    // The act of getting the locale will initialize\n    // if it is missing and add the required formats.\n    loc = localeManager.get(optLocale);\n    for (var i = 0, dif, match; dif = loc.compiledFormats[i]; i++) {\n      match = str.match(dif.reg);\n      if (match) {\n        // Note that caching the format will modify the compiledFormats array\n        // which is not a good idea to do inside its for loop, however we\n        // know at this point that we have a matched format and that we will\n        // break out below, so simpler to do it here.\n        loc.cacheFormat(dif, i);\n        set = parseFormatValues(match, dif);\n        if (isDefined(set.timestamp)) {\n          date.setTime(set.timestamp);\n          break;\n        }\n        if (isDefined(set.ampm)) {\n          handleAmpm(set.ampm);\n        }\n        if (set.utc || isDefined(set.tzHour)) {\n          handleTimezoneOffset(set.tzHour, set.tzMinute);\n        }\n        if (isDefined(set.shift) && isUndefined(set.unit)) {\n          // \"next january\", \"next monday\", etc\n          handleUnitlessShift();\n        }\n        if (isDefined(set.num) && isUndefined(set.unit)) {\n          // \"the second of January\", etc\n          handleUnitlessNum(set.num);\n        }\n        if (set.midday) {\n          // \"noon\" and \"midnight\"\n          handleMidday(set.midday);\n        }\n        if (isDefined(set.day)) {\n          // Relative day localizations such as \"today\" and \"tomorrow\".\n          handleRelativeDay(set.day);\n        }\n        if (isDefined(set.unit)) {\n          // \"3 days ago\", etc\n          handleRelativeUnit(set.unit);\n        }\n        if (set.edge) {\n          // \"the end of January\", etc\n          handleEdge(set.edge, set);\n        }\n        break;\n      }\n    }\n    if (!set) {\n      // TODO: remove in next major version\n      // Fall back to native parsing\n      date = new Date(str);\n      if (optFromUTC && dateIsValid(date)) {\n        // Falling back to system date here which cannot be parsed as UTC,\n        // so if we're forcing UTC then simply add the offset.\n        date.setTime(date.getTime() + tzOffset(date) * MINUTES);\n      }\n    } else if (relative) {\n      updateDate(date, set, false, 1);\n    } else {\n      updateDate(date, set, true, 0, optPrefer, weekdayDir, contextDate);\n    }\n    fireCallbacks();\n    return date;\n  }\n  function handleAmpm(ampm) {\n    if (ampm === 1 && set.hour < 12) {\n      // If the time is 1pm-11pm advance the time by 12 hours.\n      set.hour += 12;\n    } else if (ampm === 0 && set.hour === 12) {\n      // If it is 12:00am then set the hour to 0.\n      set.hour = 0;\n    }\n  }\n  function handleTimezoneOffset(tzHour, tzMinute) {\n    // Adjust for timezone offset\n    _utc(date, true);\n\n    // Sign is parsed as part of the hour, so flip\n    // the minutes if it's negative.\n\n    if (tzHour < 0) {\n      tzMinute *= -1;\n    }\n    var offset = tzHour * 60 + (tzMinute || 0);\n    if (offset) {\n      set.minute = (set.minute || 0) - offset;\n    }\n  }\n  function handleUnitlessShift() {\n    if (isDefined(set.month)) {\n      // \"next January\"\n      set.unit = YEAR_INDEX;\n    } else if (isDefined(set.weekday)) {\n      // \"next Monday\"\n      set.unit = WEEK_INDEX;\n    }\n  }\n  function handleUnitlessNum(num) {\n    if (isDefined(set.weekday)) {\n      // \"The second Tuesday of March\"\n      setOrdinalWeekday(num);\n    } else if (isDefined(set.month)) {\n      // \"The second of March\"\n      set.date = set.num;\n    }\n  }\n  function handleMidday(hour) {\n    set.hour = hour % 24;\n    if (hour > 23) {\n      // If the date has hours past 24, we need to prevent it from traversing\n      // into a new day as that would make it being part of a new week in\n      // ambiguous dates such as \"Monday\".\n      afterDateSet(function () {\n        advanceDate(date, 'date', trunc(hour / 24));\n      });\n    }\n  }\n  function handleRelativeDay() {\n    resetTime(date);\n    if (isUndefined(set.unit)) {\n      set.unit = DAY_INDEX;\n      set.num = set.day;\n      delete set.day;\n    }\n  }\n  function handleRelativeUnit(unitIndex) {\n    var num;\n    if (isDefined(set.num)) {\n      num = set.num;\n    } else if (isDefined(set.edge) && isUndefined(set.shift)) {\n      num = 0;\n    } else {\n      num = 1;\n    }\n\n    // If a weekday is defined, there are 3 possible formats being applied:\n    //\n    // 1. \"the day after monday\": unit is days\n    // 2. \"next monday\": short for \"next week monday\", unit is weeks\n    // 3. \"the 2nd monday of next month\": unit is months\n    //\n    // In the first case, we need to set the weekday up front, as the day is\n    // relative to it. The second case also needs to be handled up front for\n    // formats like \"next monday at midnight\" which will have its weekday reset\n    // if not set up front. The last case will set up the params necessary to\n    // shift the weekday and allow separateAbsoluteUnits below to handle setting\n    // it after the date has been shifted.\n    if (isDefined(set.weekday)) {\n      if (unitIndex === MONTH_INDEX) {\n        setOrdinalWeekday(num);\n        num = 1;\n      } else {\n        updateDate(date, {\n          weekday: set.weekday\n        }, true);\n        delete set.weekday;\n      }\n    }\n    if (set.half) {\n      // Allow localized \"half\" as a standalone colloquialism. Purposely avoiding\n      // the locale number system to reduce complexity. The units \"month\" and\n      // \"week\" are purposely excluded in the English date formats below, as\n      // \"half a week\" and \"half a month\" are meaningless as exact dates.\n      num *= set.half;\n    }\n    if (isDefined(set.shift)) {\n      // Shift and unit, ie \"next month\", \"last week\", etc.\n      num *= set.shift;\n    } else if (set.sign) {\n      // Unit and sign, ie \"months ago\", \"weeks from now\", etc.\n      num *= set.sign;\n    }\n    if (isDefined(set.day)) {\n      // \"the day after tomorrow\"\n      num += set.day;\n      delete set.day;\n    }\n\n    // Formats like \"the 15th of last month\" or \"6:30pm of next week\"\n    // contain absolute units in addition to relative ones, so separate\n    // them here, remove them from the params, and set up a callback to\n    // set them after the relative ones have been set.\n    separateAbsoluteUnits(unitIndex);\n\n    // Finally shift the unit.\n    set[English.units[unitIndex]] = num;\n    relative = true;\n  }\n  function handleEdge(edge, params) {\n    var edgeIndex = params.unit,\n      weekdayOfMonth;\n    if (!edgeIndex) {\n      // If we have \"the end of January\", then we need to find the unit index.\n      iterateOverHigherDateParams(params, function (unitName, val, unit, i) {\n        if (unitName === 'weekday' && isDefined(params.month)) {\n          // If both a month and weekday exist, then we have a format like\n          // \"the last tuesday in November, 2012\", where the \"last\" is still\n          // relative to the end of the month, so prevent the unit \"weekday\"\n          // from taking over.\n          return;\n        }\n        edgeIndex = i;\n      });\n    }\n    if (edgeIndex === MONTH_INDEX && isDefined(params.weekday)) {\n      // If a weekday in a month exists (as described above),\n      // then set it up to be set after the date has been shifted.\n      weekdayOfMonth = params.weekday;\n      delete params.weekday;\n    }\n    afterDateSet(function () {\n      var stopIndex;\n      // \"edge\" values that are at the very edge are \"2\" so the beginning of the\n      // year is -2 and the end of the year is 2. Conversely, the \"last day\" is\n      // actually 00:00am so it is 1. -1 is reserved but unused for now.\n      if (edge < 0) {\n        moveToBeginningOfUnit(date, edgeIndex, optLocale);\n      } else if (edge > 0) {\n        if (edge === 1) {\n          stopIndex = DAY_INDEX;\n          moveToBeginningOfUnit(date, DAY_INDEX);\n        }\n        moveToEndOfUnit(date, edgeIndex, optLocale, stopIndex);\n      }\n      if (isDefined(weekdayOfMonth)) {\n        setWeekday(date, weekdayOfMonth, -edge);\n        resetTime(date);\n      }\n    });\n    if (edgeIndex === MONTH_INDEX) {\n      params.specificity = DAY_INDEX;\n    } else {\n      params.specificity = edgeIndex - 1;\n    }\n  }\n  function setOrdinalWeekday(num) {\n    // If we have \"the 2nd Tuesday of June\", then pass the \"weekdayDir\"\n    // flag along to updateDate so that the date does not accidentally traverse\n    // into the previous month. This needs to be independent of the \"prefer\"\n    // flag because we are only ensuring that the weekday is in the future, not\n    // the entire date.\n    set.weekday = 7 * (num - 1) + set.weekday;\n    set.date = 1;\n    weekdayDir = 1;\n  }\n  function separateAbsoluteUnits(unitIndex) {\n    var params;\n    iterateOverDateParams(set, function (name, val, unit, i) {\n      // If there is a time unit set that is more specific than\n      // the matched unit we have a string like \"5:30am in 2 minutes\",\n      // which is meaningless, so invalidate the date...\n      if (i >= unitIndex) {\n        date.setTime(NaN);\n        return false;\n      } else if (i < unitIndex) {\n        // ...otherwise set the params to set the absolute date\n        // as a callback after the relative date has been set.\n        params = params || {};\n        params[name] = val;\n        deleteDateParam(set, name);\n      }\n    });\n    if (params) {\n      afterDateSet(function () {\n        updateDate(date, params, true, 0, false, weekdayDir);\n        if (optParams) {\n          simpleMerge(optParams, params);\n        }\n      });\n      if (set.edge) {\n        // \"the end of March of next year\"\n        handleEdge(set.edge, params);\n        delete set.edge;\n      }\n    }\n  }\n  if (contextDate && d) {\n    // If a context date is passed (\"get\" and \"unitsFromNow\"),\n    // then use it as the starting point.\n    date = cloneDateByFlag(contextDate, true);\n  } else {\n    date = getNewDate();\n  }\n  _utc(date, optFromUTC);\n  if (isString(d)) {\n    date = parseStringDate(d);\n  } else if (isDate(d)) {\n    date = cloneDateByFlag(d, optClone || forceClone);\n  } else if (isObjectType(d)) {\n    set = simpleClone(d);\n    updateDate(date, set, true);\n  } else if (isNumber(d) || d === null) {\n    date.setTime(d);\n  }\n  // A date created by parsing a string presumes that the format *itself* is\n  // UTC, but not that the date, once created, should be manipulated as such. In\n  // other words, if you are creating a date object from a server time\n  // \"2012-11-15T12:00:00Z\", in the majority of cases you are using it to create\n  // a date that will, after creation, be manipulated as local, so reset the utc\n  // flag here unless \"setUTC\" is also set.\n  _utc(date, !!optSetUTC);\n  return {\n    set: set,\n    date: date\n  };\n}\nmodule.exports = getExtendedDate;","map":{"version":3,"names":["MINUTES","require","ABBREVIATED_YEAR_REG","LocaleHelpers","DateUnitIndexes","_utc","trunc","forEach","tzOffset","isDefined","resetTime","getNewDate","updateDate","setWeekday","simpleMerge","advanceDate","isUndefined","classChecks","dateIsValid","simpleClone","isObjectType","moveToEndOfUnit","deleteDateParam","coreUtilityAliases","moveToBeginningOfUnit","iterateOverDateParams","getYearFromAbbreviation","iterateOverHigherDateParams","isNumber","isString","isDate","getOwn","English","localeManager","DAY_INDEX","WEEK_INDEX","MONTH_INDEX","YEAR_INDEX","getExtendedDate","contextDate","d","opt","forceClone","date","set","loc","afterCallbacks","relative","weekdayDir","optPrefer","optLocale","optFromUTC","optSetUTC","optParams","optClone","setupOptions","locale","parseFormatValues","match","dif","to","param","i","str","val","parseIrregular","parseValue","cloneDateByFlag","clone","Date","getTime","afterDateSet","fn","push","fireCallbacks","call","parseStringDate","toLowerCase","get","compiledFormats","reg","cacheFormat","timestamp","setTime","ampm","handleAmpm","utc","tzHour","handleTimezoneOffset","tzMinute","shift","unit","handleUnitlessShift","num","handleUnitlessNum","midday","handleMidday","day","handleRelativeDay","handleRelativeUnit","edge","handleEdge","hour","offset","minute","month","weekday","setOrdinalWeekday","unitIndex","half","sign","separateAbsoluteUnits","units","params","edgeIndex","weekdayOfMonth","unitName","stopIndex","specificity","name","NaN","module","exports"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/todo/node_modules/sugar-date/date/internal/getExtendedDate.js"],"sourcesContent":["'use strict';\n\nvar MINUTES = require('../var/MINUTES'),\n    ABBREVIATED_YEAR_REG = require('../var/ABBREVIATED_YEAR_REG'),\n    LocaleHelpers = require('../var/LocaleHelpers'),\n    DateUnitIndexes = require('../var/DateUnitIndexes'),\n    _utc = require('../../common/var/_utc'),\n    trunc = require('../../common/var/trunc'),\n    forEach = require('../../common/internal/forEach'),\n    tzOffset = require('./tzOffset'),\n    isDefined = require('../../common/internal/isDefined'),\n    resetTime = require('./resetTime'),\n    getNewDate = require('./getNewDate'),\n    updateDate = require('./updateDate'),\n    setWeekday = require('./setWeekday'),\n    simpleMerge = require('../../common/internal/simpleMerge'),\n    advanceDate = require('./advanceDate'),\n    isUndefined = require('../../common/internal/isUndefined'),\n    classChecks = require('../../common/var/classChecks'),\n    dateIsValid = require('./dateIsValid'),\n    simpleClone = require('../../common/internal/simpleClone'),\n    isObjectType = require('../../common/internal/isObjectType'),\n    moveToEndOfUnit = require('./moveToEndOfUnit'),\n    deleteDateParam = require('./deleteDateParam'),\n    coreUtilityAliases = require('../../common/var/coreUtilityAliases'),\n    moveToBeginningOfUnit = require('./moveToBeginningOfUnit'),\n    iterateOverDateParams = require('./iterateOverDateParams'),\n    getYearFromAbbreviation = require('./getYearFromAbbreviation'),\n    iterateOverHigherDateParams = require('./iterateOverHigherDateParams');\n\nvar isNumber = classChecks.isNumber,\n    isString = classChecks.isString,\n    isDate = classChecks.isDate,\n    getOwn = coreUtilityAliases.getOwn,\n    English = LocaleHelpers.English,\n    localeManager = LocaleHelpers.localeManager,\n    DAY_INDEX = DateUnitIndexes.DAY_INDEX,\n    WEEK_INDEX = DateUnitIndexes.WEEK_INDEX,\n    MONTH_INDEX = DateUnitIndexes.MONTH_INDEX,\n    YEAR_INDEX = DateUnitIndexes.YEAR_INDEX;\n\nfunction getExtendedDate(contextDate, d, opt, forceClone) {\n\n  // Locals\n  var date, set, loc, afterCallbacks, relative, weekdayDir;\n\n  // Options\n  var optPrefer, optLocale, optFromUTC, optSetUTC, optParams, optClone;\n\n  afterCallbacks = [];\n\n  setupOptions(opt);\n\n  function setupOptions(opt) {\n    opt = isString(opt) ? { locale: opt } : opt || {};\n    optPrefer  = +!!getOwn(opt, 'future') - +!!getOwn(opt, 'past');\n    optLocale  = getOwn(opt, 'locale');\n    optFromUTC = getOwn(opt, 'fromUTC');\n    optSetUTC  = getOwn(opt, 'setUTC');\n    optParams  = getOwn(opt, 'params');\n    optClone   = getOwn(opt, 'clone');\n  }\n\n  function parseFormatValues(match, dif) {\n    var set = optParams || {};\n    forEach(dif.to, function(param, i) {\n      var str = match[i + 1], val;\n      if (!str) return;\n\n      val = parseIrregular(str, param);\n\n      if (isUndefined(val)) {\n        val = loc.parseValue(str, param);\n      }\n\n      set[param] = val;\n    });\n    return set;\n  }\n\n  function parseIrregular(str, param) {\n    if (param === 'utc') {\n      return 1;\n    } else if (param === 'year') {\n      var match = str.match(ABBREVIATED_YEAR_REG);\n      if (match) {\n        return getYearFromAbbreviation(match[1], date, optPrefer);\n      }\n    }\n  }\n\n  // Force the UTC flags to be true if the source date\n  // date is UTC, as they will be overwritten later.\n  function cloneDateByFlag(d, clone) {\n    if (_utc(d) && !isDefined(optFromUTC)) {\n      optFromUTC = true;\n    }\n    if (_utc(d) && !isDefined(optSetUTC)) {\n      optSetUTC = true;\n    }\n    if (clone) {\n      d = new Date(d.getTime());\n    }\n    return d;\n  }\n\n  function afterDateSet(fn) {\n    afterCallbacks.push(fn);\n  }\n\n  function fireCallbacks() {\n    forEach(afterCallbacks, function(fn) {\n      fn.call();\n    });\n  }\n\n  function parseStringDate(str) {\n\n    str = str.toLowerCase();\n\n    // The act of getting the locale will initialize\n    // if it is missing and add the required formats.\n    loc = localeManager.get(optLocale);\n\n    for (var i = 0, dif, match; dif = loc.compiledFormats[i]; i++) {\n      match = str.match(dif.reg);\n      if (match) {\n\n        // Note that caching the format will modify the compiledFormats array\n        // which is not a good idea to do inside its for loop, however we\n        // know at this point that we have a matched format and that we will\n        // break out below, so simpler to do it here.\n        loc.cacheFormat(dif, i);\n\n        set = parseFormatValues(match, dif);\n\n        if (isDefined(set.timestamp)) {\n          date.setTime(set.timestamp);\n          break;\n        }\n\n        if (isDefined(set.ampm)) {\n          handleAmpm(set.ampm);\n        }\n\n        if (set.utc || isDefined(set.tzHour)) {\n          handleTimezoneOffset(set.tzHour, set.tzMinute);\n        }\n\n        if (isDefined(set.shift) && isUndefined(set.unit)) {\n          // \"next january\", \"next monday\", etc\n          handleUnitlessShift();\n        }\n\n        if (isDefined(set.num) && isUndefined(set.unit)) {\n          // \"the second of January\", etc\n          handleUnitlessNum(set.num);\n        }\n\n        if (set.midday) {\n          // \"noon\" and \"midnight\"\n          handleMidday(set.midday);\n        }\n\n        if (isDefined(set.day)) {\n          // Relative day localizations such as \"today\" and \"tomorrow\".\n          handleRelativeDay(set.day);\n        }\n\n        if (isDefined(set.unit)) {\n          // \"3 days ago\", etc\n          handleRelativeUnit(set.unit);\n        }\n\n        if (set.edge) {\n          // \"the end of January\", etc\n          handleEdge(set.edge, set);\n        }\n\n        break;\n      }\n    }\n\n    if (!set) {\n      // TODO: remove in next major version\n      // Fall back to native parsing\n      date = new Date(str);\n      if (optFromUTC && dateIsValid(date)) {\n        // Falling back to system date here which cannot be parsed as UTC,\n        // so if we're forcing UTC then simply add the offset.\n        date.setTime(date.getTime() + (tzOffset(date) * MINUTES));\n      }\n    } else if (relative) {\n      updateDate(date, set, false, 1);\n    } else {\n      updateDate(date, set, true, 0, optPrefer, weekdayDir, contextDate);\n    }\n    fireCallbacks();\n    return date;\n  }\n\n  function handleAmpm(ampm) {\n    if (ampm === 1 && set.hour < 12) {\n      // If the time is 1pm-11pm advance the time by 12 hours.\n      set.hour += 12;\n    } else if (ampm === 0 && set.hour === 12) {\n      // If it is 12:00am then set the hour to 0.\n      set.hour = 0;\n    }\n  }\n\n  function handleTimezoneOffset(tzHour, tzMinute) {\n    // Adjust for timezone offset\n    _utc(date, true);\n\n    // Sign is parsed as part of the hour, so flip\n    // the minutes if it's negative.\n\n    if (tzHour < 0) {\n      tzMinute *= -1;\n    }\n\n    var offset = tzHour * 60 + (tzMinute || 0);\n    if (offset) {\n      set.minute = (set.minute || 0) - offset;\n    }\n  }\n\n  function handleUnitlessShift() {\n    if (isDefined(set.month)) {\n      // \"next January\"\n      set.unit = YEAR_INDEX;\n    } else if (isDefined(set.weekday)) {\n      // \"next Monday\"\n      set.unit = WEEK_INDEX;\n    }\n  }\n\n  function handleUnitlessNum(num) {\n    if (isDefined(set.weekday)) {\n      // \"The second Tuesday of March\"\n      setOrdinalWeekday(num);\n    } else if (isDefined(set.month)) {\n      // \"The second of March\"\n      set.date = set.num;\n    }\n  }\n\n  function handleMidday(hour) {\n    set.hour = hour % 24;\n    if (hour > 23) {\n      // If the date has hours past 24, we need to prevent it from traversing\n      // into a new day as that would make it being part of a new week in\n      // ambiguous dates such as \"Monday\".\n      afterDateSet(function() {\n        advanceDate(date, 'date', trunc(hour / 24));\n      });\n    }\n  }\n\n  function handleRelativeDay() {\n    resetTime(date);\n    if (isUndefined(set.unit)) {\n      set.unit = DAY_INDEX;\n      set.num  = set.day;\n      delete set.day;\n    }\n  }\n\n  function handleRelativeUnit(unitIndex) {\n    var num;\n\n    if (isDefined(set.num)) {\n      num = set.num;\n    } else if (isDefined(set.edge) && isUndefined(set.shift)) {\n      num = 0;\n    } else {\n      num = 1;\n    }\n\n    // If a weekday is defined, there are 3 possible formats being applied:\n    //\n    // 1. \"the day after monday\": unit is days\n    // 2. \"next monday\": short for \"next week monday\", unit is weeks\n    // 3. \"the 2nd monday of next month\": unit is months\n    //\n    // In the first case, we need to set the weekday up front, as the day is\n    // relative to it. The second case also needs to be handled up front for\n    // formats like \"next monday at midnight\" which will have its weekday reset\n    // if not set up front. The last case will set up the params necessary to\n    // shift the weekday and allow separateAbsoluteUnits below to handle setting\n    // it after the date has been shifted.\n    if(isDefined(set.weekday)) {\n      if(unitIndex === MONTH_INDEX) {\n        setOrdinalWeekday(num);\n        num = 1;\n      } else {\n        updateDate(date, { weekday: set.weekday }, true);\n        delete set.weekday;\n      }\n    }\n\n    if (set.half) {\n      // Allow localized \"half\" as a standalone colloquialism. Purposely avoiding\n      // the locale number system to reduce complexity. The units \"month\" and\n      // \"week\" are purposely excluded in the English date formats below, as\n      // \"half a week\" and \"half a month\" are meaningless as exact dates.\n      num *= set.half;\n    }\n\n    if (isDefined(set.shift)) {\n      // Shift and unit, ie \"next month\", \"last week\", etc.\n      num *= set.shift;\n    } else if (set.sign) {\n      // Unit and sign, ie \"months ago\", \"weeks from now\", etc.\n      num *= set.sign;\n    }\n\n    if (isDefined(set.day)) {\n      // \"the day after tomorrow\"\n      num += set.day;\n      delete set.day;\n    }\n\n    // Formats like \"the 15th of last month\" or \"6:30pm of next week\"\n    // contain absolute units in addition to relative ones, so separate\n    // them here, remove them from the params, and set up a callback to\n    // set them after the relative ones have been set.\n    separateAbsoluteUnits(unitIndex);\n\n    // Finally shift the unit.\n    set[English.units[unitIndex]] = num;\n    relative = true;\n  }\n\n  function handleEdge(edge, params) {\n    var edgeIndex = params.unit, weekdayOfMonth;\n    if (!edgeIndex) {\n      // If we have \"the end of January\", then we need to find the unit index.\n      iterateOverHigherDateParams(params, function(unitName, val, unit, i) {\n        if (unitName === 'weekday' && isDefined(params.month)) {\n          // If both a month and weekday exist, then we have a format like\n          // \"the last tuesday in November, 2012\", where the \"last\" is still\n          // relative to the end of the month, so prevent the unit \"weekday\"\n          // from taking over.\n          return;\n        }\n        edgeIndex = i;\n      });\n    }\n    if (edgeIndex === MONTH_INDEX && isDefined(params.weekday)) {\n      // If a weekday in a month exists (as described above),\n      // then set it up to be set after the date has been shifted.\n      weekdayOfMonth = params.weekday;\n      delete params.weekday;\n    }\n    afterDateSet(function() {\n      var stopIndex;\n      // \"edge\" values that are at the very edge are \"2\" so the beginning of the\n      // year is -2 and the end of the year is 2. Conversely, the \"last day\" is\n      // actually 00:00am so it is 1. -1 is reserved but unused for now.\n      if (edge < 0) {\n        moveToBeginningOfUnit(date, edgeIndex, optLocale);\n      } else if (edge > 0) {\n        if (edge === 1) {\n          stopIndex = DAY_INDEX;\n          moveToBeginningOfUnit(date, DAY_INDEX);\n        }\n        moveToEndOfUnit(date, edgeIndex, optLocale, stopIndex);\n      }\n      if (isDefined(weekdayOfMonth)) {\n        setWeekday(date, weekdayOfMonth, -edge);\n        resetTime(date);\n      }\n    });\n    if (edgeIndex === MONTH_INDEX) {\n      params.specificity = DAY_INDEX;\n    } else {\n      params.specificity = edgeIndex - 1;\n    }\n  }\n\n  function setOrdinalWeekday(num) {\n    // If we have \"the 2nd Tuesday of June\", then pass the \"weekdayDir\"\n    // flag along to updateDate so that the date does not accidentally traverse\n    // into the previous month. This needs to be independent of the \"prefer\"\n    // flag because we are only ensuring that the weekday is in the future, not\n    // the entire date.\n    set.weekday = 7 * (num - 1) + set.weekday;\n    set.date = 1;\n    weekdayDir = 1;\n  }\n\n  function separateAbsoluteUnits(unitIndex) {\n    var params;\n\n    iterateOverDateParams(set, function(name, val, unit, i) {\n      // If there is a time unit set that is more specific than\n      // the matched unit we have a string like \"5:30am in 2 minutes\",\n      // which is meaningless, so invalidate the date...\n      if (i >= unitIndex) {\n        date.setTime(NaN);\n        return false;\n      } else if (i < unitIndex) {\n        // ...otherwise set the params to set the absolute date\n        // as a callback after the relative date has been set.\n        params = params || {};\n        params[name] = val;\n        deleteDateParam(set, name);\n      }\n    });\n    if (params) {\n      afterDateSet(function() {\n        updateDate(date, params, true, 0, false, weekdayDir);\n        if (optParams) {\n          simpleMerge(optParams, params);\n        }\n      });\n      if (set.edge) {\n        // \"the end of March of next year\"\n        handleEdge(set.edge, params);\n        delete set.edge;\n      }\n    }\n  }\n\n  if (contextDate && d) {\n    // If a context date is passed (\"get\" and \"unitsFromNow\"),\n    // then use it as the starting point.\n    date = cloneDateByFlag(contextDate, true);\n  } else {\n    date = getNewDate();\n  }\n\n  _utc(date, optFromUTC);\n\n  if (isString(d)) {\n    date = parseStringDate(d);\n  } else if (isDate(d)) {\n    date = cloneDateByFlag(d, optClone || forceClone);\n  } else if (isObjectType(d)) {\n    set = simpleClone(d);\n    updateDate(date, set, true);\n  } else if (isNumber(d) || d === null) {\n    date.setTime(d);\n  }\n  // A date created by parsing a string presumes that the format *itself* is\n  // UTC, but not that the date, once created, should be manipulated as such. In\n  // other words, if you are creating a date object from a server time\n  // \"2012-11-15T12:00:00Z\", in the majority of cases you are using it to create\n  // a date that will, after creation, be manipulated as local, so reset the utc\n  // flag here unless \"setUTC\" is also set.\n  _utc(date, !!optSetUTC);\n  return {\n    set: set,\n    date: date\n  };\n}\n\nmodule.exports = getExtendedDate;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}