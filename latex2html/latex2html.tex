\input cwebmac
% TODO make csnames array into linked list

% latex2html simple converter from latex markup to html markup
% Andrew A. Cashner
% 2015-04-14 begun
% 2015-04-21 working proof-of-concept (or of concept's limits)

% LaTeX logo from eplain.tex
\def\LaTeX{L\kern -.26em \raise .6ex \hbox{\sevenrm A}\kern -.15em \TeX}


\N{1}{1}Introduction.
This is \.{latex2html}, a rudimentary convertor from \LaTeX\ markup to HTML by
Andrew Cashner, \today.
The program reads a \LaTeX\ file written with a strictly limited subset of
markup commands and converts them to HTML5.

For this prototype version, we ignore all the preamble and focus only on the
contents of the \.{document} environment.  We require that {\it all\/} \LaTeX\
commands are written in the following format: \.{\\csname\{argument\}}.  This
means that in every case we can first find the control-sequence name and then
match it to its argument, so that in the HTML we can put opening and closing
elements around the text of the argument.

We use a \PB{\\{group}} counter to keep track of nested groups, and as we read
each new
control sequence, we store it in an array \PB{\\{csnames}[\,]} indexed to the
group
number.  At the end of each group, it is then easy to fetch the right closing
command for the HTML close tag by calling \PB{\\{csnames}[\\{group}]}.  The
control-sequence names are actually stores as integers and referenced via
macros
to reduce the amount of string comparison.

We read one character at a time, starting in \PB{\.{TEXT}} mode.  When we
encounter a
backslash, we enter \PB{\.{CSNAME}} mode and store each character into a \PB{%
\\{csnames}}
buffer until we reach a left brace ($\lbrace$).  In the case of environments,
these are written \.{\\begin\{environment\}} $\dots$ \.{\\end\{environment\}},
so the control sequence is actually the argument of \.{begin}.  Therefore, if
\PB{\\{csnames}} is \.{begin}, then we move on to the next string after the
left
brace, and store everything up to the right brace ($\rbrace$) as the
\PB{\\{csnames}}.

We convert the command into an HTML tag using a dictionary hash table indexed
to
the macros for the control-sequence names.  So \.{emph} becomes \.{em} and
\.{section} becomes \.{h1}.  (In a later stage these substitutions will be
adjustable via a YAML-style configuration file.) In a new file we write the new
HTML start-element tag surrounded by angle braces (e.g., \.{<em>}).

Once we read the control sequence and move past the $\lbrace$, we add one to
the
\PB{\\{group}} counter and enter \PB{\.{TEXT}} mode.  We copy the argument text
to the output
file.  For normal commands, when we reach a right ending brace ($\rbrace$) we
decrement the \PB{\\{group}} counter.  For environment commands, we look for
\.{\\end\{environment\}} instead of $\rbrace$; in that case we enter \PB{%
\.{END}} mode
and ignore all text until the end brace $\rbrace$. At this point we we insert
the closing tag (e.g., \.{</em>}).

At present there is no way to identify paragraphs for \.{<p>} tags.
For now we require the \LaTeX\ file to surround each paragraph in either a
\.{\\begin\{para\}} \dots \.{\\end\{para\}} environment or a \.{\\para\{\}}
command.

Remember, we are requiring pre-validated \LaTeX\ input syntax, as we do not do
any syntax checking.  We need at least a basic error mechanism to escape if
this
system goes wrong.

\Y\B\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<string.h>}\7
\X3:Global variables\X\6
\X5:Function prototypes\X\7
\&{int} \\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1%
\2\2\6
${}\{{}$\1\6
\X8:Main variables\X\6
\X7:Write csname dictionary\X\6
\X9:Open files for reading and writing\X\6
\X11:Process text\X\6
\&{return} (\T{0});\6
\4${}\}{}$\2\par
\fi

\M{2}Global variables.
\Y\B\4\D$\.{CSNAME\_LENGTH}$ \5
\T{20}\par
\B\4\D$\.{MAX\_CSNAMES}$ \5
\T{11}\par
\B\4\D$\.{FILENAME\_LENGTH}$ \5
\T{100}\par
\fi

\N{1}{3}Set up dictionary to match TeX commands and HTML tags.

\Y\B\4\X3:Global variables\X${}\E{}$\6
\&{enum} ${}\{{}$\1\6
\X4:csname macro labels\X\2\6
${}\}{}$ \\{csname\_label};\6
\&{typedef} \&{struct} ${}\{{}$\1\6
\&{char} \\{latex\_name}[\.{CSNAME\_LENGTH}];\6
\&{char} \\{html\_name}[\.{CSNAME\_LENGTH}];\2\6
${}\}{}$ \&{csname\_dict\_entry};\6
\&{csname\_dict\_entry} \\{csname\_dict}[\.{MAX\_CSNAMES}];\par
\A10.
\U1.\fi

\M{4}Now the macro names for \PB{\\{csname\_label}}.
\Y\B\4\X4:csname macro labels\X${}\E{}$\6
$\.{EMPH},\39\.{TEXTBF},\39\.{ENQUOTE},\39\.{SECTION},\39\.{SUBSECTION},\39%
\.{SUBSUBSECTION},\39\.{PARAGRAPH},\39\.{ITEMIZE},\39\.{ENUMERATE},\39\.{ITEM},%
\39{}$\.{PARA}\par
\U3.\fi

\M{5}Function: Control-sequence dictionary.

\Y\B\4\X5:Function prototypes\X${}\E{}$\6
\&{void} \\{new\_csname}(\&{int} \\{label}${},\39{}$\&{char} \\{tex}[\,]${},%
\39{}$\&{char} \\{html}[\,]);\par
\A20.
\U1.\fi

\M{6}This function creates a dictionary of control sequence names, mapped to
HTML
tags.

\Y\B\&{void} \\{new\_csname}(\&{int} \\{label}${},\39{}$\&{char} \\{tex}[%
\,]${},\39{}$\&{char} \\{html}[\,])\1\1\2\2\6
${}\{{}$\1\6
${}\\{strcpy}(\\{csname\_dict}[\\{label}].\\{latex\_name},\39\\{tex});{}$\6
${}\\{strcpy}(\\{csname\_dict}[\\{label}].\\{html\_name},\39\\{html});{}$\6
\&{return};\6
\4${}\}{}$\2\par
\fi

\M{7}Add entries to csname dictionary.

\Y\B\4\X7:Write csname dictionary\X${}\E{}$\6
$\\{new\_csname}(\.{EMPH},\39\.{"emph"},\39\.{"em"});{}$\6
${}\\{new\_csname}(\.{TEXTBF},\39\.{"textbf"},\39\.{"strong"});{}$\6
${}\\{new\_csname}(\.{ENQUOTE},\39\.{"enquote"},\39\.{"q"});{}$\6
${}\\{new\_csname}(\.{SECTION},\39\.{"section"},\39\.{"h1"});{}$\6
${}\\{new\_csname}(\.{SUBSECTION},\39\.{"subsection"},\39\.{"h2"});{}$\6
${}\\{new\_csname}(\.{SUBSUBSECTION},\39\.{"subsubsection"},\39\.{"h3"});{}$\6
${}\\{new\_csname}(\.{PARAGRAPH},\39\.{"paragraph"},\39\.{"h4"});{}$\6
${}\\{new\_csname}(\.{ITEMIZE},\39\.{"itemize"},\39\.{"ul"});{}$\6
${}\\{new\_csname}(\.{ENUMERATE},\39\.{"enumerate"},\39\.{"ol"});{}$\6
${}\\{new\_csname}(\.{ITEM},\39\.{"item"},\39\.{"li"});{}$\6
${}\\{new\_csname}(\.{PARA},\39\.{"para"},\39\.{"p"}){}$;\par
\U1.\fi

\N{1}{8}Set up file input and output.
The user gives the file name to be read as a command-line argument %
\.{latex2html
file} or \.{latex2html file.tex}.
If there is no \.{.tex} extension we add it to the filename before opening the
input file and testing for success.
For the output file, if there is a \.{.tex} extension given we strip it;
either way we add the \.{.html} extension for the output filename.


\Y\B\4\X8:Main variables\X${}\E{}$\6
\&{int} \\{group};\C{ Counter for hierarchical grouping level }\6
\&{int} \|c;\C{ Current character as \PB{\&{int}} }\6
\&{char} \\{csnames}[\.{MAX\_CSNAMES}][\.{CSNAME\_LENGTH}];\C{ Buffer for
csnames being read, ordered by group }\6
\&{FILE} ${}{*}\\{infile};{}$\6
\&{FILE} ${}{*}\\{outfile};{}$\6
\&{char} \\{infilename}[\.{FILENAME\_LENGTH}];\6
\&{char} \\{outfilename}[\.{FILENAME\_LENGTH}];\6
\&{int} \\{char\_position};\C{ Counter for char array }\par
\U1.\fi

\M{9}Open files for reading and writing.

\Y\B\4\X9:Open files for reading and writing\X${}\E{}$\6
\&{if} ${}(\\{argc}\I\T{2}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Usage:\ latex2html\ <}\)\.{filename>\\n"});{}$%
\6
\\{exit}(\.{EXIT\_FAILURE});\6
\4${}\}{}$\2\6
${}\\{strcpy}(\\{infilename},\39\\{argv}[\T{1}]);{}$\6
\&{if} ${}(\\{strcmp}({\AND}\\{infilename}[\\{strlen}(\\{infilename})-\T{4}],%
\39\.{".tex"})\I\T{0}){}$\5
${}\{{}$\1\6
${}\\{strcat}(\\{infilename},\39\.{".tex"}){}$;\C{ Add .tex extension if not
there }\6
\4${}\}{}$\2\6
${}\\{infile}\K\\{fopen}(\\{infilename},\39\.{"r"});{}$\6
\&{if} ${}(\\{infile}\E\NULL){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Unable\ to\ open\ file}\)\.{\ \%s\ for\
reading.\\n"},\39\\{infilename});{}$\6
\\{exit}(\.{EXIT\_FAILURE});\6
\4${}\}{}$\2\6
${}\\{strcpy}(\\{outfilename},\39\\{argv}[\T{1}]);{}$\6
\&{if} ${}(\\{strcmp}({\AND}\\{outfilename}[\\{strlen}(\\{outfilename})-\T{4}],%
\39\.{".tex"})\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{outfilename}[\\{strlen}(\\{outfilename})-\T{4}]\K\.{'\\0'};{}$\6
\4${}\}{}$\2\6
${}\\{strcat}(\\{outfilename},\39\.{".html"}){}$;\C{ Add or substitute .html
extension }\6
${}\\{outfile}\K\\{fopen}(\\{outfilename},\39\.{"w"});{}$\6
\&{if} ${}(\\{outfile}\E\NULL){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Unable\ to\ open\ file}\)\.{\ \%s\ for\
writing.\\n"},\39\\{outfilename});{}$\6
\\{exit}(\.{EXIT\_FAILURE});\6
\4${}\}{}$\2\par
\U1.\fi

\N{1}{10}Process text to convert commands to tags.

\Y\B\4\X3:Global variables\X${}\mathrel+\E{}$\6
\&{enum} ${}\{{}$\1\6
${}\.{TEXT},\39\.{CSNAME},\39\.{BEGIN},\39\.{END},\39\.{COMMENT}{}$\2\6
${}\}{}$ \\{mode};\par
\fi

\M{11}We build a state machine to read each character and either convert the
csnames
to HTML tags or just copy the text directly.
For \.{\\begin\{environment\}} commands, the csname is taken from the argument
of \.{\\begin\}}.
For normal commands the csname comes from the characters between the backlash
and the start brace, so \.{emph} in \.{\\emph\{word\}}.

\Y\B\4\X11:Process text\X${}\E{}$\6
$\\{mode}\K\.{TEXT};{}$\6
${}\\{group}\K\T{0};{}$\6
${}\\{char\_position}\K\T{0};{}$\6
\&{while} ${}((\|c\K\\{fgetc}(\\{infile}))\I\.{EOF}){}$\5
${}\{{}$\1\6
\&{switch} (\\{mode})\5
${}\{{}$\1\6
\X12:case TEXT mode\X\6
\X13:case CSNAME mode\X\6
\X15:case BEGIN environment mode\X\6
\X16:case END environment mode\X\6
\X17:case COMMENT mode\X\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U1.\fi

\M{12}When we are scanning normal text, we copy each character until we
encounter a
backslash, which triggers the start of a new csname, or a right brace, which
ends a group.

\Y\B\4\X12:case TEXT mode\X${}\E{}$\6
\4\&{case} \.{TEXT}:\6
\&{if} ${}(\|c\E\.{'\\\\'}){}$\5
${}\{{}$\1\6
${}\\{mode}\K\.{CSNAME};{}$\6
${}\\{char\_position}\K\T{0};{}$\6
${}\PP\\{group};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\|c\E\.{'\}'}){}$\5
${}\{{}$\1\6
${}\\{mode}\K\.{TEXT};{}$\6
\X19:Convert and print end tag\X\6
${}\MM\\{group};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\|c\E\.{'\%'}){}$\5
${}\{{}$\1\6
${}\\{mode}\K\.{COMMENT};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\\{fputc}(\|c,\39\\{outfile});{}$\6
\&{break};\par
\U11.\fi

\M{13}When we are inside a csname, we store the characters into \PB{%
\\{csnames}[\\{group}]} for
the current group, until we reach the end of the csname at the left brace.

\Y\B\4\X13:case CSNAME mode\X${}\E{}$\6
\4\&{case} \.{CSNAME}:\6
\&{if} ${}(\|c\E\.{'\{'}){}$\5
${}\{{}$\1\6
${}\\{csnames}[\\{group}][\\{char\_position}]\K\.{'\\0'};{}$\6
\X14:Check for environment begin or end\X\6
\X18:Convert and print start tag\X\6
${}\\{mode}\K\.{TEXT};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\\{csnames}[\\{group}][\\{char\_position}]\K{}$(\&{char}) \|c;\6
${}\PP\\{char\_position};{}$\6
\&{break};\par
\U11.\fi

\M{14}We check to see if the csname is \.{begin} or \.{end} because these cases
require special treatment.

\Y\B\4\X14:Check for environment begin or end\X${}\E{}$\6
\&{if} ${}(\\{strcmp}(\\{csnames}[\\{group}],\39\.{"begin"})\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{char\_position}\K\T{0};{}$\6
${}\\{mode}\K\.{BEGIN};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{strcmp}(\\{csnames}[\\{group}],\39\.{"end"})\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{mode}\K\.{END};{}$\6
\&{continue};\6
\4${}\}{}$\2\par
\U13.\fi

\M{15}When we have found a \.{\\begin} environment command, we use the csname
that
follows in braces instead of \.{begin}.

\Y\B\4\X15:case BEGIN environment mode\X${}\E{}$\6
\4\&{case} \.{BEGIN}:\6
\&{if} ${}(\|c\E\.{'\}'}){}$\5
${}\{{}$\1\6
${}\\{csnames}[\\{group}][\\{char\_position}]\K\.{'\\0'};{}$\6
\X18:Convert and print start tag\X\6
${}\\{mode}\K\.{TEXT};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\\{csnames}[\\{group}][\\{char\_position}]\K{}$(\&{char}) \|c;\6
${}\PP\\{char\_position};{}$\6
\&{break};\par
\U11.\fi

\M{16}When we have found a \.{\\end} environment command, we do not store any
of the
command, but simply treat it as the end of a group.
(Remember, we are assuming properly formed \LaTeX\ input.)

\Y\B\4\X16:case END environment mode\X${}\E{}$\6
\4\&{case} \.{END}:\6
\&{if} ${}(\|c\E\.{'\}'}){}$\5
${}\{{}$\1\6
${}\\{mode}\K\.{TEXT};{}$\6
${}\MM\\{group};{}$\6
\X19:Convert and print end tag\X\6
\4${}\}{}$\2\6
\&{continue};\6
\&{break};\par
\U11.\fi

\M{17}If a comment character \.{'\%'} is found, we omit everything up to the
next newline.
\Y\B\4\X17:case COMMENT mode\X${}\E{}$\6
\4\&{case} \.{COMMENT}:\6
\&{if} ${}(\|c\E\.{'\\n'}){}$\5
${}\{{}$\1\6
${}\\{mode}\K\.{TEXT};{}$\6
\4${}\}{}$\2\6
\&{break};\par
\U11.\fi

\M{18}When we have identified a csname, we convert it to a start HTML tag.

\Y\B\4\X18:Convert and print start tag\X${}\E{}$\6
\\{csname2html}(\\{csnames}[\\{group}]);\6
${}\\{fprintf}(\\{outfile},\39\.{"<\%s>"},\39\\{csnames}[\\{group}]){}$;\par
\Us13\ET15.\fi

\M{19}At the end of each group, we convert the most recent csname to an {\it
end} HTMl
tag.

\Y\B\4\X19:Convert and print end tag\X${}\E{}$\6
\\{csname2html}(\\{csnames}[\\{group}]);\6
${}\\{fprintf}(\\{outfile},\39\.{"</\%s>"},\39\\{csnames}[\\{group}]){}$;\par
\Us12\ET16.\fi

\M{20}Function \PB{\\{csname2html}}.

\Y\B\4\X5:Function prototypes\X${}\mathrel+\E{}$\6
\&{void} \\{csname2html}(\&{char} \\{currentcsname}[\,]);\par
\fi

\M{21}This function converts a TeX csname to an HTML tag according to the rules
setup in our dictionary.
It takes the most recently read csname, \PB{\\{csnames}[\\{group}]}, as its
argument,
and replaces that string with the HTML version.

\Y\B\&{void} \\{csname2html}(\&{char} \\{currentcsname}[\,])\1\1\2\2\6
${}\{{}$\1\6
\&{int} \|i;\C{ Loop counter }\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\.{MAX\_CSNAMES};{}$ ${}\PP\|i){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{strcmp}(\\{currentcsname},\39\\{csname\_dict}[\|i].\\{latex%
\_name})\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{strcpy}(\\{currentcsname},\39\\{csname\_dict}[\|i].\\{html\_name});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return};\6
\4${}\}{}$\2\par
\fi


\inx
\fin
\con
